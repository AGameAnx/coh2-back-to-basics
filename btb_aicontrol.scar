
--------------------------------------------------------------------------------------------------------------------
-- AIControl.scar
-- This script is used to control specific AI unit types individually with custom logic
-- Created by AGameAnx
--------------------------------------------------------------------------------------------------------------------


--string.lpad = function(str, len, char)
--	if char == nil then char = ' ' end
--	return string.rep(char, len - string.len(str))..str
--end

local function normalizeVector(pos)
	local length = math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)
	return World_Pos(pos.x / length, pos.y / length, pos.z / length)
end

g_AIControl_Enable = true
g_AIControl_Pause = false

AIControl = {}
local wHalfWidth = World_GetWidth()/2
local wHalfHeight = World_GetLength()/2

AIControl.UpdateInterval = 2 -- Update ticks (seconds)
AIControl.Players = {}
AIControl.PlayerCount = 0

AIControl.Grid = {
	Settings = {
		SplitUpdates = true, -- If true, the update will be split to be performed over the course of UpdateInterval rather than once per UpdateInterval
		SplitUpdateCount = 4, -- Number of updates to be done during each UpdateInterval if SplitUpdates are enabled (make sure that dividing update interval by this doesn't produce long fractions)
		
		-- These settings will only be used on game start, changing them later on will not affect the actual values
		Init_Dimensions = {11, 11}, -- Initial dimensions table
		
		AutoDimensionsEnable = true, -- if this is enabled, world will automatically be divided into areas with dimensions closest to supplied dimensions table
		                             -- Otherwise, init dimensions will be used directly to divide map into that many parts
		HistoryLengthModifier = 100, -- Higher modifiers mean that units present in certain areas will be remembered longer
	},
	
	Dimensions = {0, 0, 1, 1}, -- {x divisions, y divisions, cell width, cell height}
	--DataHistoryStart = 0, -- the time in seconds in which we start our history data gathering
	DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell
	DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell
	Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell
	AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell
	ControlPoints = {}, -- double array of Dimensions[1] * Dimensions[2] size containing spawnable locations or middle positions for each cell
	DisabledLocations = {}, -- in case HQ setup was unsuccessful in a certain point, we disable further attempts of setting up there
	AIMarkerCount = 0,
	AIMarkers = {}, -- array containing invisible entities used by AI for building defensive structures
	
	MainControlUpdateStep = 0,
	SplitUpdateStep = 0,
	SplitUpdateSquads = {},
	
	SetDimensions = function(x, y, auto, SpawnAIMarkers)
		local worldWidth, worldLength = World_GetWidth(), World_GetLength()
		if auto == nil then auto = AIControl.Grid.Settings.AutoDimensionsEnable end
		if SpawnAIMarkers == nil then SpawnAIMarkers = AIControl.Grid.Settings.SpawnAIMarkers end
		for i=1, AIControl.Grid.Dimensions[1] do
			if AIControl.Grid.DataSquads[i] then
				for j=1, AIControl.Grid.Dimensions[2] do
					if AIControl.Grid.DataSquads[i][j] then
						SGroup_Destroy(AIControl.Grid.DataSquads[i][j][1])
						SGroup_Destroy(AIControl.Grid.DataSquads[i][j][2])
					end
				end
			end
		end
		if auto then
			AIControl.Grid.Dimensions[1] = math.floor(worldWidth/x)
			AIControl.Grid.Dimensions[2] = math.floor(worldLength/y)
		else
			AIControl.Grid.Dimensions[1] = x
			AIControl.Grid.Dimensions[2] = y
		end
		AIControl.Grid.Dimensions[3] = worldWidth/AIControl.Grid.Dimensions[1]
		AIControl.Grid.Dimensions[4] = worldLength/AIControl.Grid.Dimensions[2]
		--print("Dimensions: "..AIControl.Grid.Dimensions[1].."*"..AIControl.Grid.Dimensions[3].." x "..AIControl.Grid.Dimensions[2].."*"..AIControl.Grid.Dimensions[4])
		AIControl.Grid.SetupControlPoints()
		AIControl.Grid.ResetupAIMarkers(nil, SpawnAIMarkers)
		AIControl.Grid.DataHistory = {}
		AIControl.Grid.DataSquads = {}
		for i=1, AIControl.Grid.Dimensions[1] do
			AIControl.Grid.DataHistory[i] = {}
			AIControl.Grid.DataSquads[i] = {}
			for j=1, AIControl.Grid.Dimensions[2] do
				AIControl.Grid.DataHistory[i][j] = {0, 0}
				AIControl.Grid.DataSquads[i][j] = {SGroup_CreateIfNotFound("AIControl.Grid.DataSquads["..i.."]["..j.."][1]"), SGroup_CreateIfNotFound("AIControl.Grid.DataSquads["..i.."]["..j.."][2]")}
			end
		end
		--AIControl.Grid.DataHistoryStart = World_GetGameTime()/AIControl.UpdateInterval
	end,
	SetupControlPoints = function()
		local wHalfWidth = World_GetWidth()/2
		local wHalfHeight = World_GetLength()/2
		local halfWidth = AIControl.Grid.Dimensions[3]/2
		local halfHeight = AIControl.Grid.Dimensions[4]/2
		
		for i=1, AIControl.Grid.Dimensions[1] do
			AIControl.Grid.ControlPoints[i] = {}
			AIControl.Grid.ControlPoints[i] = {}
			for j=1, AIControl.Grid.Dimensions[2] do
				AIControl.Grid.ControlPoints[i][j] = World_Pos(i*AIControl.Grid.Dimensions[3]-halfWidth-wHalfWidth, 0, j*AIControl.Grid.Dimensions[4]-halfHeight-wHalfHeight)
			end
		end
	end,
	ResetData = function()
		for i=1, AIControl.Grid.Dimensions[1] do
			AIControl.Grid.Data[i] = {}
			AIControl.Grid.DataCounts[i] = {}
			AIControl.Grid.AveragePosData[i] = {}
			for j=1, AIControl.Grid.Dimensions[2] do
				AIControl.Grid.Data[i][j] = {0, 0}
				AIControl.Grid.DataCounts[i][j] = {0, 0}
				SGroup_Clear(AIControl.Grid.DataSquads[i][j][1])
				SGroup_Clear(AIControl.Grid.DataSquads[i][j][2])
				AIControl.Grid.AveragePosData[i][j] = {AIControl.Grid.ControlPoints[i][j], AIControl.Grid.ControlPoints[i][j]}
			end
		end
	end,
	
	UpdateAIPlayers = function() -- returns squad counts
		AIControl.PlayerCount = 0
		AIControl.Players = {}
		local squadCounts = {0, 0}
		for i=1,World_GetPlayerCount() do
			local player = World_GetPlayerAt(i)
			if not Player_IsHuman(player) then
				AIControl.PlayerCount = AIControl.PlayerCount + 1
				AIControl.Players[AIControl.PlayerCount] = i
			end
			local team = Player_GetTeam(player)+1
			if team == 1 or team == 2 then
				squadCounts[team] = squadCounts[team] + SGroup_CountSpawned(Player_GetSquads(player))
			end
		end
		return squadCounts
	end,
	Update = function()
		local squadCounts = AIControl.Grid.UpdateAIPlayers()
		if not AIControl.Grid.Settings.SplitUpdates or AIControl.Grid.SplitUpdateStep == 0 then
			AIControl.Grid.ResetData()
			for i=1,AIControl.Grid.Dimensions[1] do
				for j=1,AIControl.Grid.Dimensions[2] do
					AIControl.Grid.AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
					if squadCounts[1] > 0 then
						AIControl.Grid.DataHistory[i][j][1] = math.max(0, AIControl.Grid.DataHistory[i][j][1] - AIControl.Grid.DataHistory[i][j][1]/squadCounts[1]/(1+math.max(0, AIControl.Grid.Settings.HistoryLengthModifier)))
					end
					if squadCounts[2] > 0 then
						AIControl.Grid.DataHistory[i][j][2] = math.max(0, AIControl.Grid.DataHistory[i][j][2] - AIControl.Grid.DataHistory[i][j][2]/squadCounts[2]/(1+math.max(0, AIControl.Grid.Settings.HistoryLengthModifier)))
					end
				end
			end
			
			if AIControl.Grid.SplitUpdateStep == 0 then
				AIControl.Grid.SplitUpdateSquads = {}
				
				local allSquads = {}
				local sqCount = 0
				for i=1,World_GetPlayerCount() do
					local player = World_GetPlayerAt(i)
					local team = Player_GetTeam(player)+1
					if team == 1 or team == 2 then
						local pSquads = Player_GetSquads(player)
						for j=1,SGroup_CountSpawned(pSquads) do
							sqCount = sqCount + 1
							allSquads[sqCount] = SGroup_GetSpawnedSquadAt(pSquads, j)
						end
					end
				end
				
				if AIControl.Grid.SplitUpdateStep <= sqCount then
					local sqPerStep = math.ceil(sqCount/AIControl.Grid.Settings.SplitUpdateCount)
					for i=1,AIControl.Grid.Settings.SplitUpdateCount do
						AIControl.Grid.SplitUpdateSquads[i] = SGroup_CreateIfNotFound("sg_aicontrol_splitupdatesquads_"..i)
						for j=i*sqPerStep,math.min(sqCount, (i+1)*sqPerStep) do
							if allSquads[j] then
								SGroup_Add(AIControl.Grid.SplitUpdateSquads[i], allSquads[j])
							end
						end
					end
				end
			end
		end
		
		local squads
		if AIControl.Grid.Settings.SplitUpdates then
			AIControl.Grid.SplitUpdateStep = AIControl.Grid.SplitUpdateStep + 1
			squads = AIControl.Grid.SplitUpdateSquads[AIControl.Grid.SplitUpdateStep]
			if AIControl.Grid.SplitUpdateStep >= AIControl.Grid.Settings.SplitUpdateCount then
				AIControl.Grid.SplitUpdateStep = 0
			end
		else
			squads = SGroup_CreateIfNotFound("sg_temp_aicontrol_squads")
			for i=1,World_GetPlayerCount() do
				local player = World_GetPlayerAt(i)
				local team = Player_GetTeam(player)+1
				if team == 1 or team == 2 then
					local pSquads = Player_GetSquads(player)
					for j=1,SGroup_CountSpawned(pSquads) do
						local s = SGroup_GetSpawnedSquadAt(pSquads, j)
						SGroup_Add(squads, s)
					end
				end
			end
		end
		for i=1,SGroup_CountSpawned(squads) do
			local s = SGroup_GetSpawnedSquadAt(squads, i)
			local player = Squad_GetPlayerOwner(s)
			local team = Player_GetTeam(player)+1
			local enemyTeam
			if team == 1 then
				enemyTeam = 2
			else
				enemyTeam = 1
			end
			local position = Squad_GetPosition(s)
			local x = math.min(AIControl.Grid.Dimensions[1], math.max(1, math.floor((position.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1))
			local y = math.min(AIControl.Grid.Dimensions[2], math.max(1, math.floor((position.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1))
			
			local squadWeight = 1
			local squadHealthMax = Squad_GetHealthMax(s)
			
			--[[local canSee = true
			for j=1,World_GetPlayerCount() do
				local p = World_GetPlayerAt(j)
				local pTeam = Player_GetTeam(p)+1
				if pTeam == enemyTeam then
					canSee = Player_CanSeeSquad(p, s, false)
					break
				end
			end]]
			
			if Squad_GetMax(s) == 1 then
				if squadHealthMax > 200 then
					squadWeight = squadHealthMax/(50+(squadHealthMax-200)/10)
				else
					squadWeight = squadHealthMax/50
				end
			elseif Squad_Count(s) > 0 then
				squadWeight = Squad_Count(s)/2+squadHealthMax/150
			end
			
			AIControl.Grid.Data[x][y][team] = AIControl.Grid.Data[x][y][team] + squadWeight
			AIControl.Grid.DataCounts[x][y][team] = AIControl.Grid.DataCounts[x][y][team] + 1
			AIControl.Grid.DataHistory[x][y][team] = AIControl.Grid.DataHistory[x][y][team] + squadWeight/squadCounts[team]
			SGroup_Add(AIControl.Grid.DataSquads[x][y][team], s)
			
			AIControl.Grid.AveragePosData[x][y][team].x = AIControl.Grid.AveragePosData[x][y][team].x+position.x
			--AIControl.Grid.AveragePosData[x][y][team].y = AIControl.Grid.AveragePosData[x][y][team].y+position.y
			AIControl.Grid.AveragePosData[x][y][team].z = AIControl.Grid.AveragePosData[x][y][team].z+position.z
		end
		SGroup_Destroy(squads)
		
		if not AIControl.Grid.Settings.SplitUpdates or AIControl.Grid.SplitUpdateStep == 0 then
			for i=1,AIControl.Grid.Dimensions[1] do
				for j=1,AIControl.Grid.Dimensions[2] do
					if AIControl.Grid.DataCounts[i][j][1] > 1 then
						AIControl.Grid.AveragePosData[i][j][1].x = AIControl.Grid.AveragePosData[i][j][1].x/AIControl.Grid.DataCounts[i][j][1]
						--AIControl.Grid.AveragePosData[i][j][1].y = AIControl.Grid.AveragePosData[i][j][1].y/AIControl.Grid.DataCounts[i][j][1]
						AIControl.Grid.AveragePosData[i][j][1].z = AIControl.Grid.AveragePosData[i][j][1].z/AIControl.Grid.DataCounts[i][j][1]
					else
						AIControl.Grid.AveragePosData[i][j][1] = AIControl.Grid.ControlPoints[i][j]
					end
					if AIControl.Grid.DataCounts[i][j][2] > 1 then
						AIControl.Grid.AveragePosData[i][j][2].x = AIControl.Grid.AveragePosData[i][j][2].x/AIControl.Grid.DataCounts[i][j][2]
						--AIControl.Grid.AveragePosData[i][j][2].y = AIControl.Grid.AveragePosData[i][j][2].y/AIControl.Grid.DataCounts[i][j][2]
						AIControl.Grid.AveragePosData[i][j][2].z = AIControl.Grid.AveragePosData[i][j][2].z/AIControl.Grid.DataCounts[i][j][2]
					else
						AIControl.Grid.AveragePosData[i][j][2] = AIControl.Grid.ControlPoints[i][j]
					end
				end
			end
			dr_clear("aicontrolcustomdebug")
			--AIControl.Grid.DebugOutput(1)
			--AIControl.Grid.DebugOutput(2)
			
			AIControl.Grid.MainControlUpdateStep = AIControl.Grid.MainControlUpdateStep + 1
			if AIControl.Grid.MainControlUpdateStep >= AIControl.MainControl.Settings.Init_UpdateFreq then
				AIControl.Grid.MainControlUpdateStep = 0
				AIControl.MainControl.Update()
			end
			
			-- Get artillery position
			local highestPos = {{0, 0}, {0, 0}}
			local highestDanger = {0, 0}
			local highestPosFOW = {{0, 0}, {0, 0}}
			local highestDangerFOW = {0, 0}
			for team=1,2 do
				local enemyTeam
				if team == 1 then
					enemyTeam = 2
				else
					enemyTeam = 1
				end
				local player
				for i=1,World_GetPlayerCount() do
					local p = World_GetPlayerAt(i)
					if Player_GetTeam(p)+1 == team then
						player = p
						break
					end
				end
				for i=1, AIControl.Grid.Dimensions[1] do
					for j=1, AIControl.Grid.Dimensions[2] do
						if AIControl.Grid.Data[i][j][team]/AIControl.Grid.Data[i][j][enemyTeam] < 0.25 then
							if AIControl.Grid.Data[i][j][enemyTeam] > highestDangerFOW[team] then
								highestDangerFOW[team] = AIControl.Grid.Data[i][j][enemyTeam]
								highestPosFOW[team] = {i, j}
							end
							if AIControl.Grid.Data[i][j][enemyTeam] > highestDanger[team] and Player_CanSeePosition(player, AIControl.Grid.AveragePosData[i][j][enemyTeam]) then
								highestDanger[team] = AIControl.Grid.Data[i][j][enemyTeam]
								highestPos[team] = {i, j}
							end
						end
					end
				end
			end
			for p=1,AIControl.PlayerCount do
				local player = World_GetPlayerAt(AIControl.Players[p])
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					local team = Player_GetTeam(player)+1
					local enemyTeam
					if team == 1 then enemyTeam = 2
					else enemyTeam = 1 end
					local pos
					if highestDangerFOW[team] < 0.75 then
						AI_DoString(player, "AIControlArtyPosFOW=nil")
					else
						pos = AIControl.Grid.AveragePosData[highestPosFOW[team][1]][highestPosFOW[team][2]][enemyTeam]
						AI_DoString(player, string.format("AIControlArtyPosFOW=World_Pos(%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z))
					end
					if highestDanger[team] < 0.5 then
						AI_DoString(player, "AIControlArtyPos=nil")
					else
						pos = AIControl.Grid.AveragePosData[highestPos[team][1]][highestPos[team][2]][enemyTeam]
						AI_DoString(player, string.format("AIControlArtyPos=World_Pos(%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z))
					end
				end
			end
		end
	end,
	DebugOutput = function(team)
		local function pr(i, j, team, val, offset)
			if offset == nil then offset = 0 end
			dr_text2d("aicontrolcustomdebug", 0.005+(team-1)*0.475+(AIControl.Grid.Dimensions[2]-j)/80, 0.005+offset+(AIControl.Grid.Dimensions[1]-i)/75, val, 255, 255, 255)
		end
		for i=1, AIControl.Grid.Dimensions[1] do
			for j=1, AIControl.Grid.Dimensions[2] do
				pr(i, j, team, string.format("%d", AIControl.Grid.Data[i][j][team]))
			end
		end
	end
}

AIControl.Pathfinding = {
	Settings = {
		Precision = 1.5,
		EntityBlueprint = BP_GetEntityBlueprint('23d6cdb82724460dbcb21e1a9162e473:ebps\\races\\german\\vehicles\\stug_iii_sdkfz_141_1\\stug_iii_e_sdkfz_141_1_mp.xml')
	},
	StepsTotal = {1,1},
	Data = {},
	CurrentYStep = 1,
	Entity = nil,
	DebugPrint = function(path)
		dr_clear("aicontrol_pathfinding_mapdebug")
		for y = 1,AIControl.Pathfinding.StepsTotal[2] do
			local line = ''
			for x = 1,AIControl.Pathfinding.StepsTotal[1] do
				if AIControl.Pathfinding.Data[x][y] then
					--if y == AIControl.Pathfinding.CurrentYStep then
					--	dr_text2d("aicontrol_pathfinding_mapdebug", 0.007+x*0.004, 0.007+y*0.0045, '-', 255, 255, 255)
					--end
				else
					dr_text2d("aicontrol_pathfinding_mapdebug", 0.007+x*0.004, 0.007+y*0.0045, '+', 0, 0, 0)
				end
			end
		end
		
		if path then
			dr_clear("aicontrol_pathfinding_pathdebug")
			for i,v in pairs(path) do
				dr_text2d("aicontrol_pathfinding_pathdebug", 0.007+v[1]*0.004, 0.007+v[2]*0.0045, 'o', 255, 0, 0)
			end
		end
	end,
	
	-- Pseudocode from http://en.wikipedia.org/wiki/A_star
	GetPath = function(start, goal)
		local closedset = {} -- The set of nodes already evaluated.
		local closedsetCount = 0
		local openset = {{start[1],start[2]}} -- The set of tentative nodes to be evaluated, initially containing the start node
		local opensetCount = 1
		local came_from = {} -- The map of navigated nodes.
		
		local g_score = {}
		g_score[start[1]] = {}
		g_score[start[1]][start[2]] = 0 -- Cost from start along best known path.
		-- Estimated total cost from start to goal through y.
		local f_score = {}
		f_score[start[1]] = {}
		f_score[start[1]][start[2]] = g_score[start[1]][start[2]] + AIControl.Pathfinding.CostEstimate(start, goal)
		
		local stepsTotal = 0
		while opensetCount > 0 and stepsTotal < 150 do
			stepsTotal = stepsTotal + 1
			
			local currenti = 1 --the node in openset having the lowest f_score[] value
			for i=2,opensetCount do
				if f_score[openset[currenti][1]][openset[currenti][2]] > f_score[openset[i][1]][openset[i][2]] then
					currenti = i
				end
			end
			
			local current = {openset[currenti][1],openset[currenti][2]}
			
			if current[1] == goal[1] and current[2] == goal[2] then
				return AIControl.Pathfinding.ReconstructPath(came_from, goal)
			end
			
			--remove current from openset
			for i=currenti,opensetCount do
				openset[i] = openset[i+1]
			end
			opensetCount = opensetCount - 1
			
			-- add current to closedset
			closedsetCount = closedsetCount + 1
			closedset[closedsetCount] = {current[1],current[2]}
			
			local neighbour_nodes = AIControl.Pathfinding.GetNeighbours(current)
			local neighbourCount = table.getn(neighbour_nodes)
			for neighbourIndex = 1,neighbourCount do
				local neighbour = neighbour_nodes[neighbourIndex]
				local notInClosedSet = true
				for i=1,closedsetCount do
					if neighbour[1] == closedset[i][1] and neighbour[2] == closedset[i][2] then
						notInClosedSet = false
						break
					end
				end
				if notInClosedSet then
					local tentative_g_score = g_score[current[1]][current[2]] + AIControl.Pathfinding.DistBetween(current, neighbour)
					
					local notInOpenset = true
					for i=1,opensetCount do
						if (neighbour[1] == openset[i][1]) and (neighbour[2] == openset[i][2]) then
							notInOpenset = false
							break
						end
					end
					if notInOpenset or tentative_g_score < g_score[neighbour[1]][neighbour[2]] then
						if not came_from[neighbour[1]] then
							came_from[neighbour[1]] = {}
						end
						came_from[neighbour[1]][neighbour[2]] = {current[1],current[2]}
						
						if not g_score[neighbour[1]] then
							g_score[neighbour[1]] = {}
						end
						g_score[neighbour[1]][neighbour[2]] = tentative_g_score
						
						if not f_score[neighbour[1]] then
							f_score[neighbour[1]] = {}
						end
						f_score[neighbour[1]][neighbour[2]] = g_score[neighbour[1]][neighbour[2]] + AIControl.Pathfinding.CostEstimate(neighbour, goal)
						
						if notInOpenset then
							opensetCount = opensetCount + 1
							openset[opensetCount] = {neighbour[1],neighbour[2]}
						end
					end
				end
			end
		end
		return AIControl.Pathfinding.ReconstructPath(came_from, goal)
	end,
	ReconstructPath = function(came_from, current_node)
		if came_from[current_node[1]] and came_from[current_node[1]][current_node[2]] then
			local p = AIControl.Pathfinding.ReconstructPath(came_from, came_from[current_node[1]][current_node[2]])
			p[table.getn(p)+1] = current_node
			return p
		else
			return {current_node}
		end
	end,
	GetNeighbours = function(cell)
		local result = {}
		local resultn = 0
		
		local leftOK = false
		local topOK = false
		local rightOK = false
		local bottomOK = false
		
		-- left
		if cell[1]-1 >= 1 then
			leftOK = true
			if AIControl.Pathfinding.Data[cell[1]-1][cell[2]] then
				resultn = resultn + 1
				result[resultn] = {cell[1]-1, cell[2]}
			end
		end
		-- top
		if cell[2]-1 >= 1 then
			topOK = true
			if AIControl.Pathfinding.Data[cell[1]][cell[2]-1] then
				resultn = resultn + 1
				result[resultn] = {cell[1], cell[2]-1}
			end
		end
		-- right
		if cell[1]+1 <= AIControl.Pathfinding.StepsTotal[1] then
			rightOK = true
			if AIControl.Pathfinding.Data[cell[1]+1][cell[2]] then
				resultn = resultn + 1
				result[resultn] = {cell[1]+1, cell[2]}
			end
		end
		-- bottom
		if cell[2]+1 <= AIControl.Pathfinding.StepsTotal[2] then
			bottomOK = true
			if AIControl.Pathfinding.Data[cell[1]][cell[2]+1] then
				resultn = resultn + 1
				result[resultn] = {cell[1], cell[2]+1}
			end
		end
		
		-- topleft
		if topOK and leftOK and AIControl.Pathfinding.Data[cell[1]-1][cell[2]-1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]-1, cell[2]-1}
		end
		-- topright
		if topOK and rightOK and AIControl.Pathfinding.Data[cell[1]+1][cell[2]-1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]+1, cell[2]-1}
		end
		-- bottomleft
		if bottomOK and leftOK and AIControl.Pathfinding.Data[cell[1]-1][cell[2]+1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]-1, cell[2]+1}
		end
		-- bottomright
		if bottomOK and rightOK and AIControl.Pathfinding.Data[cell[1]+1][cell[2]+1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]+1, cell[2]+1}
		end
		
		return result
	end,
	DistBetween = function(start, goal)
		local xdist = goal[1]-start[1]
		local ydist = goal[2]-start[2]
		return xdist^2 + ydist^2
	end,
	CostEstimate = function(start, goal)
		return 1 -- AIControl.Pathfinding.DistBetween(start, goal)
	end,
	
	-- A* pathfinding algorithm
	-- Code taken and modified from https://github.com/philnelson/A-Star-Pathfinding-For-Lua
	--[[CalcMoves = function(startx, starty, tx, ty)
		-- Returns:
		--  closedlist - a list with the checked nodes
		--  OR nil if all the available nodes have been checked but the target hasn't been found
		
		local map = AIControl.Pathfinding.Data
		
		-- variables
		local openlist = {} -- Initialize table to store possible moves
		local closedlist = {}  -- Initialize table to store checked gridsquares
		local listk = 1  -- List counter
		local closedk = 0 -- Closedlist counter
		local tempH = math.abs(startx-tx) + math.abs(starty-ty)
		local tempG = 0
		local xsize = AIControl.Pathfinding.StepsTotal[1] -- horizontal map size
		local ysize = AIControl.Pathfinding.StepsTotal[2] -- vertical map size
		local curbase = {} -- Current square from which to check possible moves
		local basis = 1 -- Index of current base
		
		openlist[1] = {x=startx, y=starty, g=0, h=tempH, f=0+tempH, par=1} -- Make starting point in list
		
		-- Growing loop
		local stepsTotal = 0
		while listk > 0 and stepsTotal < 200 do
			stepsTotal = stepsTotal + 1
			
			-- Get the lowest f of the openlist
			local lowestF = openlist[listk].f
			basis = listk
			for k = listk,1,-1 do
				if openlist[k].f < lowestF then
					lowestF = openlist[k].f
					basis = k
				end
			end
			
			closedk = closedk+1
			table.insert(closedlist, closedk, openlist[basis])
			
			curbase = closedlist[closedk] -- define current base from which to grow list
			
			-- Booleans defining if they're OK to add
			-- (must be reset for each while loop)
			local rightOK = true
			local leftOK = true
			local downOK = true 
			local upOK = true
			local topRightOK = true
			local topLeftOK = true
			local bottomRightOK = true
			local bottomLeftOK = true

			-- Look through closedlist
			if closedk > 0 then
				for k = 1,closedk do
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y then
						rightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y then
						leftOK = false
					end
					if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y+1 then
						downOK = false
					end
					if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y-1 then
						upOK = false
					end
					
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y-1 then
						topRightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y-1 then
						topLeftOK = false
					end
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y+1 then
						bottomrRightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y+1 then
						bottomLeftOK = false
					end
				end
			end
			
			-- Check if next points are on the map and within moving distance
			if curbase.x+1 > xsize then rightOK = false topRightOK = false bottomRightOK = false end
			if curbase.x-1 < 1     then leftOK = false topLeftOK = false bottomLeftOK = false end
			if curbase.y+1 > ysize then downOK = false bottomRightOK = false bottomLeftOK = false end
			if curbase.y-1 < 1     then upOK = false topRightOK = false topLeftOK = false end
			
			-- If it IS on the map, check map for obstacles
			-- (Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
			if rightOK and map[curbase.y][curbase.x+1] == false then rightOK = false end
			if leftOK and map[curbase.y][curbase.x-1] == false then leftOK = false end
			if downOK and map[curbase.y+1][curbase.x] == false then downOK = false end
			if upOK and map[curbase.y-1][curbase.x] == false then upOK = false end
			
			if topRightOK and map[curbase.y-1][curbase.x+1] == false then topRightOK = false end
			if topLeftOK and map[curbase.y-1][curbase.x-1] == false then topLeftOK = false end
			if bottomRightOK and map[curbase.y+1][curbase.x+1] == false then bottomRightOK = false end
			if bottomLeftOK and map[curbase.y+1][curbase.x-1] == false then bottomLeftOK = false end
			
			-- check if the move from the current base is shorter then from the former parrent
			tempG = curbase.g+1
			for k = 1,listk do
				if rightOK and openlist[k].x == curbase.x+1 and openlist[k].y == curbase.y and openlist[k].g > tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs(curbase.y-ty)
					table.insert(openlist, k, {x=curbase.x+1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					rightOK = false
				end
				if leftOK and openlist[k].x==curbase.x-1 and openlist[k].y==curbase.y and openlist[k].g > tempG then
					tempH = math.abs((curbase.x-1)-tx) + math.abs(curbase.y-ty)
					table.insert(openlist, k, {x=curbase.x-1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					leftOK = false
				end
				if downOK and openlist[k].x==curbase.x and openlist[k].y==curbase.y+1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x)-tx) + math.abs(curbase.y+1-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					downOK = false
				end
				if upOK and openlist[k].x==curbase.x and openlist[k].y==curbase.y-1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x)-tx) + math.abs(curbase.y-1-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					upOK = false
				end
				
				if topRightOK and openlist[k].x == curbase.x+1 and openlist[k].y == curbase.y-1 and openlist[k].g > tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x+1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					topRightOK = false
				end
				if topLeftOK and openlist[k].x==curbase.x-1 and openlist[k].y==curbase.y-1 and openlist[k].g > tempG then
					tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x-1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					topLeftOK = false
				end
				if bottomRightOK and openlist[k].x==curbase.x+1 and openlist[k].y==curbase.y+1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y+1)-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					bottomRightOK = false
				end
				if bottomLeftOK and openlist[k].x==curbase.x+1 and openlist[k].y==curbase.y-1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					bottomLeftOK = false
				end
			end
			
			-- Add points to openlist
			if rightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs(curbase.y-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if leftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs(curbase.y-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if downOK then
				listk = listk+1
				tempH = math.abs(curbase.x-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if upOK then
				listk = listk+1
				tempH = math.abs(curbase.x-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			
			if topRightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if topLeftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if bottomRightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if bottomLeftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			
			table.remove(openlist, basis)
			listk = listk-1
			
			if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
				return closedlist
			end
		end
		
		return closedlist
	end,
	CalcPath = function(closedlist)
		-- closedlist - a list with the checked nodes.
		--  OR nil if all the available nodes have been checked but the target hasn't been found.
		-- Returns:
		--  a path is a list with all the x and y coords of the nodes of the path to the target.
		--  OR nil if closedlist==nil
		
		if closedlist==nil then
			return nil
		end
		
		local path = {}
		local pathIndex = {}
		local last = table.getn(closedlist)
		table.insert(pathIndex, 1, last)
		
		local i = 1
		while pathIndex[i] > 1 do
			i = i+1
			table.insert(pathIndex, i, closedlist[ pathIndex[i-1] ].par)
		end
		
		for n = table.getn(pathIndex),1,-1 do
			table.insert(path, {x=closedlist[ pathIndex[n] ].x, y=closedlist[ pathIndex[n] ].y})
		end
		
		closedlist = nil
		
		AIControl.Pathfinding.DebugPrint(path)
		
		return path
	end,]]
	
	FindClosestUnobstructedPoint = function(startx, starty, bias)
		local angle
		local directionMultiplier
		if bias then
			angle = math.acos((startx*bias[1]+starty*bias[2]) / (math.sqrt(startx*startx + starty*starty) * math.sqrt(bias[1]*bias[1] + bias[2]*bias[2])))
			directionMultiplier = 1
		else
			angle = World_GetRand(1, 360) / 180 * 3.14
			directionMultiplier = 0
		end
		local direction = {math.cos(angle), math.sin(angle)}
		local startx = math.max(2, math.min(AIControl.Pathfinding.StepsTotal[1]-1, startx))
		local starty = math.max(2, math.min(AIControl.Pathfinding.StepsTotal[2]-1, starty))
		local curx = startx
		local cury = starty
		local radius = 2
		if AIControl.Pathfinding.Data[curx][cury] then
			return {curx, cury}
		end
		while radius < 4 do
			curx = curx + direction[1]*directionMultiplier
			cury = cury + direction[2]*directionMultiplier
			local curxv = math.floor(curx+0.5)
			local curyv = math.floor(cury+0.5)
			if not (curxv >= 1 and curxv <= AIControl.Pathfinding.StepsTotal[1] and curyv >= 1 and curyv <= AIControl.Pathfinding.StepsTotal[2]) then
				break
			end
			for x=-radius,radius do
				local testx = curxv+x
				if testx >= 1 and testx <= AIControl.Pathfinding.StepsTotal[1] then
					for y=-radius,radius do
						local testy = curyv+y
						if testy >= 1 and testy <= AIControl.Pathfinding.StepsTotal[2] then
							if AIControl.Pathfinding.Data[testx][testy] then
								return {testx,testy}
							end
						end
					end
				end
			end
			
			radius = radius + 1
		end
		return {startx, starty}
	end,
	
	Reset = function()
		AIControl.Pathfinding.StepsTotal[1] = math.floor(World_GetWidth()/AIControl.Pathfinding.Settings.Precision)+1
		AIControl.Pathfinding.StepsTotal[2] = math.floor(World_GetLength()/AIControl.Pathfinding.Settings.Precision)+1
		AIControl.Pathfinding.Data = {}
		for x=1,AIControl.Pathfinding.StepsTotal[1] do
			AIControl.Pathfinding.Data[x] = {}
			for y=1,AIControl.Pathfinding.StepsTotal[2] do
				AIControl.Pathfinding.Data[x][y] = false
			end
		end
		AIControl.Pathfinding.ReconstructFullMap()
	end,
	ReconstructPart = function()
		
		local halfWidth = AIControl.Pathfinding.Settings.Precision/2
		
		for step=1,3 do
			for x=1,AIControl.Pathfinding.StepsTotal[1] do
				AIControl.Pathfinding.Data[x][AIControl.Pathfinding.CurrentYStep] = false
			end
			if AIControl.Pathfinding.CurrentYStep ~= 1 and AIControl.Pathfinding.CurrentYStep ~= AIControl.Pathfinding.StepsTotal[2] then
				for x=2,AIControl.Pathfinding.StepsTotal[1]-1 do
					local pos = World_GetSpawnablePosition(World_Pos(
						x*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfWidth,
						0,
						AIControl.Pathfinding.CurrentYStep*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfHeight
					), AIControl.Pathfinding.Entity)
					local posx = math.floor((pos.x + wHalfWidth) / AIControl.Pathfinding.Settings.Precision)+1
					local posy = math.floor((pos.z + wHalfHeight) / AIControl.Pathfinding.Settings.Precision)+1
					AIControl.Pathfinding.Data[posx][posy] = true
				end
			end
			
			AIControl.Pathfinding.CurrentYStep = AIControl.Pathfinding.CurrentYStep + 1
			if AIControl.Pathfinding.CurrentYStep > AIControl.Pathfinding.StepsTotal[2] then
				AIControl.Pathfinding.CurrentYStep = 1
			end
		end
		
		--AIControl.Pathfinding.DebugPrint()
	end,
	ReconstructFullMap = function()
		local halfWidth = AIControl.Pathfinding.Settings.Precision/2
		
		for x=2,AIControl.Pathfinding.StepsTotal[1]-1 do
			for y=2,AIControl.Pathfinding.StepsTotal[2]-1 do
				local pos = World_GetSpawnablePosition(World_Pos(
					x*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfWidth,
					0,
					y*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfHeight
				), AIControl.Pathfinding.Entity)
				local posx = math.floor((pos.x + wHalfWidth) / AIControl.Pathfinding.Settings.Precision)+1
				local posy = math.floor((pos.z + wHalfHeight) / AIControl.Pathfinding.Settings.Precision)+1
				AIControl.Pathfinding.Data[posx][posy] = true
			end
		end
		
		--[[print('Pathfinding:');
		for y = 1,AIControl.Pathfinding.StepsTotal[2] do
			local line = ''
			for x = 1,AIControl.Pathfinding.StepsTotal[1] do
				if AIControl.Pathfinding.Data[x][y] then
					line = line..' '
				else
					line = line..'█'
				end
			end
			print(line)
		end]]
		
		--AIControl.Pathfinding.DebugPrint()
	end,
	Init = function()
		AIControl.Pathfinding.Entity = Entity_CreateENV(AIControl.Pathfinding.Settings.EntityBlueprint, World_Pos(-wHalfWidth, 0, -wHalfHeight), World_Pos(1, 0, 0))
		Entity_DeSpawn(AIControl.Pathfinding.Entity)
		
		dr_setdisplay("aicontrol_pathfinding_mapdebug", true)
		dr_setautoclear("aicontrol_pathfinding_mapdebug", false)
		dr_clear("aicontrol_pathfinding_mapdebug")
		
		dr_setdisplay("aicontrol_pathfinding_pathdebug", true)
		dr_setautoclear("aicontrol_pathfinding_pathdebug", false)
		dr_clear("aicontrol_pathfinding_pathdebug")
		
		AIControl.Pathfinding.Reset()
		Rule_AddInterval(AIControl.Pathfinding.ReconstructPart, 0.1)
	end
}

AIControl.__Init2 = function()
	AIControl.Grid.Update()
	AIControl.Pathfinding.Init()
	AIControl.MainControl.Init()
	
	if AIControl.Grid.Settings.SplitUpdates then
		Rule_AddInterval(AIControl.Grid.Update, AIControl.UpdateInterval/AIControl.Grid.Settings.SplitUpdateCount)
	else
		Rule_AddInterval(AIControl.Grid.Update, AIControl.UpdateInterval)
	end
end
AIControl.__Init = function()
	if g_AIControl_Enable then
		dr_setdisplay("aicontrolcustomdebug", true)
		dr_setautoclear("aicontrolcustomdebug", false)
		dr_clear("aicontrolcustomdebug")
		
		AIControl.Grid.SetDimensions(AIControl.Grid.Settings.Init_Dimensions[1], AIControl.Grid.Settings.Init_Dimensions[2])
		AIControl.Grid.UpdateAIPlayers()
		AIControl.Grid.ReduceMarkerCount()
		
		Rule_AddOneShot(AIControl.__Init2, 1)
	end
end

AIControl.Init = function()
	Rule_AddOneShot(AIControl.__Init, 1)
end

Scar_AddInit(AIControl.Init)

--------------------------------------------------------------------------------------------------------------------

UNIT_CONTROL_TYPE = {
	SETUP = 1, -- (team weapon)
	GENERIC = 2, -- (at/tanks/etc)
	KEEP_DISTANCE = 3, -- (mobile arty) - NOT IMPLEMENTED YET
}

AIControl.MainControl = {
	Settings = {
		Init_UpdateFreq = 1, -- how many normal AI control updates we'll update this script
		SecondaryUpdateTicks = 8, -- every n updates we'll check for new HQs
		
		UnitControl = {
			UnitSettings = { -- [Blueprint ID] = {control type, default range, step count, setup target angle check threshold}
				--[[[TRACE_ALLIES] = {
					[BP_GetID(SBP.ALLIES.HEAVYMG)] =               {UNIT_CONTROL_TYPE.SETUP, 2, 4, 30},
					[BP_GetID(SBP.ALLIES.CAPTURE_MG)] =            {UNIT_CONTROL_TYPE.SETUP, 2, 4, 30},
					
					[BP_GetID(SBP.ALLIES.MORTAR)] =                {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					
					[BP_GetID(SBP.ALLIES.PARATROOPER_AT_57MM)] =   {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.ALLIES.AT_57MM)] =               {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.ALLIES.CAPTURE_AT)] =            {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					
					--[BP_GetID(SBP.ALLIES.M7)] =                    {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
					--[BP_GetID(SBP.ALLIES.CALLIOPE)] =              {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
				},
				[TRACE_ALLIES_COMMONWEALTH] = {
					[BP_GetID(SBP.CW.VICKERSMG)] =                 {UNIT_CONTROL_TYPE.SETUP, 2, 3, 30},
					[BP_GetID(SBP.CW.COMMANDOS_MG42_SP)] =         {UNIT_CONTROL_TYPE.SETUP, 2, 3, 30},
					[BP_GetID(SBP.CW.CAPTURE_MG)] =                {UNIT_CONTROL_TYPE.SETUP, 2, 3, 30},
					
					[BP_GetID(SBP.CW.MORTAR)] =                    {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					[BP_GetID(SBP.CW.COMMANDOS_MORTAR)] =          {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					[BP_GetID(SBP.CW.CAPTURE_MORTAR)] =            {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					
					[BP_GetID(SBP.CW.CAPTURE_AXIS_ATGUN)] =        {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.CW.CAPTURE_ATGUN)] =             {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					--[BP_GetID(SBP.CW.SIXPOUNDER)] =                {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					
					--[BP_GetID(SBP.CW.PRIEST)] =                    {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
				},
				[TRACE_AXIS] = {
					[BP_GetID(SBP.AXIS.HEAVYMG)] =                 {UNIT_CONTROL_TYPE.SETUP, 2, 4, 30},
					
					[BP_GetID(SBP.AXIS.MORTAR)] =                  {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					[BP_GetID(SBP.AXIS.CAPTURE_MORTAR_AXIS)] =     {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					
					[BP_GetID(SBP.AXIS.PAK_38)] =                  {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.AXIS.PAK_40)] =                  {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.AXIS.CAPTURE_AT)] =              {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					[BP_GetID(SBP.AXIS.CAPTURE_AT_AXIS)] =         {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					
					--[BP_GetID(SBP.AXIS.NEBELWERFER)] =             {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
					--[BP_GetID(SBP.AXIS.HALFTRACK_STUKA)] =         {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
					
				},
				[TRACE_AXIS_PANZER_ELITE] = {
					[BP_GetID(SBP.ELITE.HEAVYMG)] =                {UNIT_CONTROL_TYPE.SETUP, 2, 4, 30},
					[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_HMG)] =    {UNIT_CONTROL_TYPE.SETUP, 2, 4, 30},
					
					[BP_GetID(SBP.ELITE.MORTAR)] =                 {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_MORTAR)] = {UNIT_CONTROL_TYPE.SETUP, 3, 5, -1},
					
					--[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_PAK)] =    {UNIT_CONTROL_TYPE.SETUP, 3, 5, 20},
					
					--[BP_GetID(SBP.ELITE.MARDER)] =                 {UNIT_CONTROL_TYPE.GENERIC, 3, 5},
					--[BP_GetID(SBP.ELITE.NASHORN)] =                {UNIT_CONTROL_TYPE.GENERIC, 3, 5},
					
					--[BP_GetID(SBP.ELITE.HUMMEL)] =                 {UNIT_CONTROL_TYPE.KEEP_DISTANCE, 10},
				},]]
			},
			
			HistoryMultiplier = 0.001, --
			CoverSearchRadius = 6, -- how far do we search for cover in meters
		},
		
		VehicleControl = {
			ExcludeFromControl = {
				[TRACE_ALLIES] = {
					
				},
				[TRACE_ALLIES_COMMONWEALTH] = {
					
				},
				[TRACE_AXIS] = {
				
				},
				[TRACE_AXIS_PANZER_ELITE] = {
				
				}
			}
		},
	},
	
	SecondaryUpdateTicks = 0,
	
	-- SGroups
	Vehicles = {},
	UnitControls = {},
	
	LockedSquads = {{}, {}},
	
	UnitControlTargets = {{}, {}},
	UnitControlUnlockTimers = {{}, {}},
	UnitControlIdleTimers = {{}, {}},
	
	VehicleControl = {
		RepairsRetreat = {{}, {}},
		FacingCmdTimers = {{}, {}},
	},
	
	Init = function()
		AIControl.MainControl.Vehicles = {SGroup_CreateIfNotFound("AIControl.MainControl.VT1"), SGroup_CreateIfNotFound("AIControl.MainControl.VT2")}
		AIControl.MainControl.UnitControls = {SGroup_CreateIfNotFound("AIControl.MainControl.TWT1"), SGroup_CreateIfNotFound("AIControl.MainControl.TWT2")}
		
		AIControl.MainControl.SecondaryUpdate()
		AIControl.MainControl.Update()
	end,
	
	GetSafetyData = function(centerX, centerY, team)
		local enemyTeam = Team_GetEnemyTeam(team)
		
		return {
			AIControl.Grid.Data[centerX][centerY][enemyTeam],
			AIControl.Grid.DataHistory[centerX][centerY][enemyTeam],
			AIControl.Grid.Data[centerX][centerY][team],
			AIControl.Grid.DataHistory[centerX][centerY][team]
		}
	end,
	GetSurroundingSafetyData = function(gridPos, team, distance, maxDistance)
		local safetyData = AIControl.MainControl.GetSafetyData(gridPos[1], gridPos[2], team)
		local distanceMultiplier = math.min(1, 1.1 - distance/maxDistance)
		return {gridPos[1], gridPos[2], safetyData[1] * distanceMultiplier, safetyData[2] * distanceMultiplier, safetyData[3] * distanceMultiplier, safetyData[4] * distanceMultiplier}
	end,
	GetSurroundingSafety = function(pos, dist, steps, team)
		local result, resultCount = {}, 0
		
		local maxPointDistance
		if dist == 0 then
			resultCount = resultCount + 1
			result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData(pos, team, 0, 1)
			dist = 1
			maxPointDistance = math.sqrt((steps+1)^2+(steps+1)^2)
		else
			maxPointDistance = math.sqrt(steps^2+steps^2)
		end
		
		for x = dist,dist+steps do
			local curx
			curx = pos[1]+x
			if curx <= AIControl.Grid.Dimensions[1] then
				for y=dist,dist+steps do
					local pointDistance = math.sqrt((x-dist)^2 + (y-dist)^2)
					local cury
					cury = pos[2]+y
					if cury <= AIControl.Grid.Dimensions[2] then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
					cury = pos[2]-y
					if cury >= 1 then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
				end
			end
			curx = pos[1]-x
			if curx >= 1 then
				for y=dist,dist+steps do
					local pointDistance = math.sqrt((x-dist)^2 + (y-dist)^2)
					local cury
					cury = pos[2]+y
					if cury <= AIControl.Grid.Dimensions[2] then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
					cury = pos[2]-y
					if cury >= 1 then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
				end
			end
		end
		return result
	end,
	
	Update = function()
		if g_AIControl_Pause then
			return
		end
		
		--print("Updating")
		
		AIControl.MainControl.SecondaryUpdateTicks = AIControl.MainControl.SecondaryUpdateTicks + 1
		if AIControl.MainControl.SecondaryUpdateTicks >= AIControl.MainControl.Settings.SecondaryUpdateTicks then
			AIControl.MainControl.SecondaryUpdate()
			AIControl.MainControl.SecondaryUpdateTicks = 0
		end
		
		--local dimDiameter = math.sqrt(AIControl.Grid.Dimensions[3]*AIControl.Grid.Dimensions[3]+AIControl.Grid.Dimensions[4]*AIControl.Grid.Dimensions[4])*1.05
		
		local function getHeadingVector(pos, headingPos) -- currently unused
			return normalizeVector(World_Pos(headingPos.x - pos.x, headingPos.y - pos.y, headingPos.z - pos.z))
		end
		
		-- Area safety
		local AreaSafetyData = {}
		
		for team=1,2 do
			local enemyTeam = Team_GetEnemyTeam(team)
			
			-- # Unit Control #
			local sg = SGroup_Create("aicontrol_uc_tempsg")
			for i=1,SGroup_CountSpawned(AIControl.MainControl.UnitControls[team]) do
				local squad = SGroup_GetSpawnedSquadAt(AIControl.MainControl.UnitControls[team], i)
				local squadGameID = Squad_GetGameID(squad)
				local player = Squad_GetPlayerOwner(squad)
				
				local raceStr = Player_GetRaceName(player)
				local setting = AIControl.MainControl.Settings.UnitControl.UnitSettings[raceStr][BP_GetID(Squad_GetBlueprint(squad))]
				if setting then
					local pos = Squad_GetPosition(squad)
					local x = math.floor((pos.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1
					local y = math.floor((pos.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1
					
					--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
					SGroup_Single(sg, squad)
					
					local syncWeapon = SyncWeapon_GetFromSGroup(sg)
					--local syncWeaponEntity = SyncWeapon_GetEntity(syncWeapon)
					local doCalculations = true
					
					if TacticFilter_Retreat(squad) then
						doCalculations = false
						if AIControl.MainControl.LockedSquads[team][squadGameID] then
							if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
								AI_UnlockSquad(player, squad)
							end
							AIControl.MainControl.LockedSquads[team][squadGameID] = nil
						end
					else
						if setting[1] == UNIT_CONTROL_TYPE.SETUP then
							if not syncWeapon then -- If our team weapon has been destroyed, we move back to HQ to reinforce
								doCalculations = false
								if Squad_Count(squad) < Squad_GetMax(squad) then
									--print("  Team weapon lost, retreating/moving back to HQ")
									if not AIControl.MainControl.LockedSquads[team][squadGameID] then
										--print("  locked squad")
										if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
											AI_LockSquad(player, squad)
										end
										AIControl.MainControl.LockedSquads[team][squadGameID] = true
									end
									Cmd_Move(sg, Player_GetStartingPosition(player))
									Cmd_Retreat(sg)
								else
									--print("  Detected bad team weapon squad! Removing from calculations")
									if AIControl.MainControl.LockedSquads[team][squadGameID] then
										--print("  unlocked squad")
										if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
											AI_UnlockSquad(player, squad)
										end
										AIControl.MainControl.LockedSquads[team][squadGameID] = nil
									end
									--SGroup_Remove(AIControl.MainControl.UnitControls[team], squad)
								end
							end
						end
					end
					if doCalculations and not Squad_IsInHoldEntity(squad) and not Squad_IsRetreating(squad) then
						
						local isUnderAttack = Squad_IsUnderAttack(squad, 2)
						--local isAttacking = SyncWeapon_IsAttacking(syncWeapon, 2)
						--local isAttacking2 = Squad_IsAttacking(squad, 10)
						--print("  isUnderAttack: "..tostring(isUnderAttack))
						--print("  isAttacking: "..tostring(isAttacking))
						
						--[[if not (Squad_IsMoving(squad) or isUnderAttack or isAttacking or AIControl.MainControl.LockedSquads[team][squadGameID]) then
							if not AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] then
								AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] = 0
							elseif AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] > 1 then
								if targetSafetyData[1][3] > 0 then
									Command_SquadPosPos(player, sg, SCMD_Move, pos, getHeadingVector(pos, AIControl.Grid.AveragePosData[ targetSafetyData[1][1] ][ targetSafetyData[1][2] ][enemyTeam]))
										--World_Pos(targetSafetyData[1][1]*AIControl.Grid.Dimensions[3], targetSafetyData[1][1].y, targetSafetyData[1][2]*AIControl.Grid.Dimensions[4])
									--print("  setting up idle team weapon")
								end
							else
								AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] = AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] + 1
							end
						else
							AIControl.MainControl.UnitControlIdleTimers[team][squadGameID] = nil
						end]]
						
						local surroundingSafety = AIControl.MainControl.GetSurroundingSafety({x, y}, 0, 1, team)
						
						local collectiveDanger = 0
						for i,v in pairs(surroundingSafety) do
							collectiveDanger = collectiveDanger + v[3] + v[4]*AIControl.MainControl.Settings.UnitControl.HistoryMultiplier
						end
						
						local lockSquad = false
						
						local targetSafetyData = AIControl.MainControl.GetSurroundingSafety({x, y}, setting[2], setting[3], team)
						table.sort(targetSafetyData, function(a, b) return a[3] > b[3] end)
						
						if collectiveDanger > 3 then
							
							-- We are in danger
							
							lockSquad = true
							
							if AIControl.MainControl.UnitControlTargets[team][squadGameID] and AIControl.MainControl.UnitControlTargets[team][squadGameID][1] then
								
								-- already have move back target
								
								Cmd_Move(sg, AIControl.MainControl.UnitControlTargets[team][squadGameID][2])
								--print("  moving endangered team weapon")
							end
							
							if collectiveDanger > 15 then
								--print("  > retreating")
								Cmd_Move(sg, Player_GetStartingPosition(player))
								Cmd_Retreat(sg)
							else
								--print("  > moving away")
								
								local playerHQPosition = Player_GetStartingPosition(player)
								local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
								
								local highestDangerPosition = AIControl.Grid.AveragePosData[ targetSafetyData[1][1] ][ targetSafetyData[1][2] ][enemyTeam]
								local highestDangerDirection = normalizeVector(Util_ScarPos(
									highestDangerPosition.x - pos.x,
									highestDangerPosition.z - pos.z
								))
								
								local secondHighestDangerPosition = AIControl.Grid.AveragePosData[ targetSafetyData[2][1] ][ targetSafetyData[2][2] ][enemyTeam]
								local secondHighestDangerDirection = normalizeVector(Util_ScarPos(
									secondHighestDangerPosition.x - pos.x,
									secondHighestDangerPosition.z - pos.z
								))
								
								local retreatDirection = normalizeVector(Util_ScarPos(
									-highestDangerDirection.x*1.35-secondHighestDangerDirection.x*0.5+directionToHq.x*2,
									-highestDangerDirection.z*1.35-secondHighestDangerDirection.z*0.5+directionToHq.z*2
								))
								
								local retreatDistance = math.min(90, math.max(45, 0.5*(collectiveDanger-5)))
								
								AIControl.MainControl.UnitControlTargets[team][squadGameID] = {true, Util_ScarPos(
									pos.x + retreatDirection.x*retreatDistance,
									pos.z + retreatDirection.z*retreatDistance
								)}
								Cmd_Move(sg, AIControl.MainControl.UnitControlTargets[team][squadGameID][2])
							end
						elseif targetSafetyData[1][3] > 2 then
							
							lockSquad = true
							
							local setupWell = false
							--print(tostring(AIControl.MainControl.UnitControlTargets[team][squadGameID]))
							if AIControl.MainControl.UnitControlTargets[team][squadGameID] and not AIControl.MainControl.UnitControlTargets[team][squadGameID][1] then
								--if isAttacking then
								--	setupWell = true
								--else
									--print("  checking if facing properly")
									local target = AIControl.MainControl.UnitControlTargets[team][squadGameID][3]
									local curx = math.floor((target.x+wHalfWidth) /AIControl.Grid.Dimensions[3])+1
									local cury = math.floor((target.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1
									--print(string.format("  + pos: (%.2f, %.2f) x: %d y: %d", target.x, target.z, curx, cury))
									if curx >= 1 and curx <= AIControl.Grid.Dimensions[1] and cury >= 1 and cury <= AIControl.Grid.Dimensions[2] then
										local safetyData = AIControl.MainControl.GetSafetyData(curx, cury, team)
										
										local curTargetV = Util_ScarPos(target.x - pos.x, target.z - pos.z)
										local highestThreatV = Util_ScarPos(
											targetSafetyData[1][1]*AIControl.Grid.Dimensions[3]-wHalfWidth - pos.x,
											targetSafetyData[1][2]*AIControl.Grid.Dimensions[4]-wHalfHeight - pos.z
										)
										
										local angle = math.acos(
											(curTargetV.x*highestThreatV.x+curTargetV.z*highestThreatV.z) /
											(math.sqrt(curTargetV.x*curTargetV.x + curTargetV.z*curTargetV.z) * math.sqrt(highestThreatV.x*highestThreatV.x + highestThreatV.z*highestThreatV.z))
										)
										
										if safetyData[1] > targetSafetyData[1][3] / 2.5 or (targetSafetyData[1][3] > 0 and (setting[4] == -1 or angle > setting[4])) then
											if not AIControl.MainControl.UnitControlTargets[team][squadGameID] then
												AIControl.MainControl.UnitControlTargets[team][squadGameID] = {false, pos, AIControl.Grid.AveragePosData[curx][cury][enemyTeam]}
											end
											setupWell = true
											break
										end
									end
								--end
							end
							if setupWell and World_DistancePointToPoint(pos, AIControl.MainControl.UnitControlTargets[team][squadGameID][2]) > AIControl.MainControl.Settings.UnitControl.CoverSearchRadius*3 then
								setupWell = false
							end
							if setupWell then
								--print("  setup well")
								--[[if World_DistancePointToPoint(pos, AIControl.MainControl.UnitControlTargets[team][squadGameID][2]) > AIControl.MainControl.Settings.UnitControl.CoverSearchRadius then
									--print("  moving to setup location")
									Command_SquadPosFacing(player, sg, SCMD_Move, AIControl.MainControl.UnitControlTargets[team][squadGameID][2],
										AIControl.MainControl.UnitControlTargets[team][squadGameID][3], false)
									--getHeadingVector(AIControl.MainControl.UnitControlTargets[team][squadGameID][2]
								end]]
							else
								local coverPos = Squad_FindCover(squad, pos, AIControl.MainControl.Settings.UnitControl.CoverSearchRadius) 
								
								--print("  loc min danger: "..targetSafetyData[table.getn(targetSafetyData)][3].." max danger: "..targetSafetyData[1][3])
								
								local heading = AIControl.Grid.AveragePosData[ targetSafetyData[1][1] ][ targetSafetyData[1][2] ][enemyTeam]
								
								AIControl.MainControl.UnitControlTargets[team][squadGameID] = {false, coverPos, heading}
								--print("  GOT NEW SETUP LOCATION!!!")
								
								--Entity_CreateENV(EBP.SP.BOAT, coverPos, heading)
								--Entity_CreateENV(EBP.SP.BOAT, heading, coverPos)
								
								Command_SquadPosFacing(player, sg, SCMD_Move, coverPos, heading, false)
							end
							
						end
						
						if lockSquad then
							if not AIControl.MainControl.LockedSquads[team][squadGameID] then
								--print("  locked squad")
								if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
									AI_LockSquad(player, squad)
								end
								AIControl.MainControl.LockedSquads[team][squadGameID] = true
							end
						else
							if AIControl.MainControl.UnitControlTargets[team][squadGameID] then
								AIControl.MainControl.UnitControlTargets[team][squadGameID] = nil
								AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] = 0
							elseif AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] then
								AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] = AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] + 1
								if AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] > 4 then
									if AIControl.MainControl.LockedSquads[team][squadGameID] then
										--print("  # timed unlocked squad")
										if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
											AI_UnlockSquad(player, squad)
										end
									end
									AIControl.MainControl.LockedSquads[team][squadGameID] = nil
									AIControl.MainControl.UnitControlUnlockTimers[team][squadGameID] = nil
								end
							else
								if AIControl.MainControl.LockedSquads[team][squadGameID] then
									--print("  # unlocked squad")
									if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
										AI_UnlockSquad(player, squad)
									end
									AIControl.MainControl.LockedSquads[team][squadGameID] = nil
								end
							end
						end
					end
				end
			end
			SGroup_Destroy(sg)
			
			-- # Vehicle Control #
			local sg = SGroup_Create("aicontrol_v_tempsg")
			for i=1,SGroup_CountSpawned(AIControl.MainControl.Vehicles[team]) do
				local squad = SGroup_GetSpawnedSquadAt(AIControl.MainControl.Vehicles[team], i)
				if not Squad_HasCritical(squad, CRIT.VEH.IMMOBILIZE) then
					local squadGameID = Squad_GetGameID(squad)
					local player = Squad_GetPlayerOwner(squad)
					local healthPercentage = Squad_GetHealthPercentage(squad)
					--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
					
					SGroup_Single(sg, squad)
					
					local pos = Squad_GetPosition(squad)
					local x = math.floor((pos.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1
					local y = math.floor((pos.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1
					
					local playerHQPosition = Player_GetStartingPosition(player)
					
					local lockSquad = false
					
					local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
					local initialStep = 0
					local stepsTotal = 9
					local maxDist = initialStep + stepsTotal
					local surroundingSafety = AIControl.MainControl.GetSurroundingSafety({x, y}, initialStep, stepsTotal, team)
					table.sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
					
					local collectiveDanger = 0
					for j,v in pairs(surroundingSafety) do
						local dist = math.sqrt((v[1]-x)^2 + (v[2]-y)^2)/maxDist
						local distMult = (1 - dist + dist*0.15)
						collectiveDanger = collectiveDanger + v[3] * 30 / math.min(30, math.max(1, dist*14)) * distMult - v[5]*0.325 * distMult
					end
					
					collectiveDanger = collectiveDanger / (healthPercentage + (1-healthPercentage)*0.1)
					
					local highestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[1][1] ][ surroundingSafety[1][2] ][enemyTeam]
					local highestDangerDirection = normalizeVector(Util_ScarPos(
						highestDangerPosition.x - pos.x,
						highestDangerPosition.z - pos.z
					))
					
					local secondHighestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[2][1] ][ surroundingSafety[2][2] ][enemyTeam]
					local secondHighestDangerDirection = normalizeVector(Util_ScarPos(
						secondHighestDangerPosition.x - pos.x,
						secondHighestDangerPosition.z - pos.z
					))
					
					local retreatDirection = normalizeVector(Util_ScarPos(
						-highestDangerDirection.x*1.35-secondHighestDangerDirection.x*0.5+directionToHq.x*2,
						-highestDangerDirection.z*1.35-secondHighestDangerDirection.z*0.5+directionToHq.z*2
					))
					
					local lowHealth = false
					
					-- Retreat on low health
					if (AIControl.MainControl.VehicleControl.RepairsRetreat[team][squadGameID] and healthPercentage < 0.9)
							or Squad_HasCritical(squad, CRIT.VEH.DAMAGE_ENGINE)
							or Squad_HasCritical(squad, CRIT.VEH.MOBILITY_MAJOR)
							or Squad_HasCritical(squad, CRIT.VEH.MAIN_WEAPON_DESTROYED)
							or Squad_HasCritical(squad, CRIT.VEH.AXIS_KILL_TOP_MG)
							or healthPercentage < 0.65 then
						lockSquad = true
						lowHealth = true
						--print('  RETREATING DUE TO LOW HEALTH!')
					else
						AIControl.MainControl.VehicleControl.RepairsRetreat[team][squadGameID] = nil
					end
					
					local dangerRequiredToRetreat = 42
					
					local retreatDistance
					if lowHealth then
						retreatDistance = 110
					else
						retreatDistance = math.min(110, 3*(collectiveDanger-dangerRequiredToRetreat))
					end
					
					local retreatLocation = Util_ScarPos(
						pos.x + retreatDirection.x*retreatDistance,
						pos.z + retreatDirection.z*retreatDistance
					)
					
					-- Retreat if in danger
					if not lockSquad then
						-- Retreat if in danger
						--print('collective danger: '..collectiveDanger)
						--print('required danger to retreat: '..dangerRequiredToRetreat)
						if collectiveDanger > dangerRequiredToRetreat then
							--print('  RETREATING DUE TO BEING IN DANGER!')
							lockSquad = true
						end
					end
					
					if lockSquad then
						
						local inSafety = false
						if lowHealth then
							local enemySafetyData = AIControl.MainControl.GetSafetyData(x, y, enemyTeam)
							if collectiveDanger < -2 then
								Cmd_Stop(sg)
								inSafety = true
							end
						elseif retreatDistance < 20 then
							inSafety = true
						end
						
						if not inSafety then
							if (not lowHealth or World_DistancePointToPoint(pos, retreatLocation) > 15) and World_DistancePointToPoint(pos, playerHQPosition) > 15 then
								local precisionHalfWidth = AIControl.Pathfinding.Settings.Precision/2
								local pathfindingTarget = AIControl.Pathfinding.FindClosestUnobstructedPoint(
									math.floor((retreatLocation.x-precisionHalfWidth+wHalfWidth)/AIControl.Pathfinding.Settings.Precision)+1,
									math.floor((retreatLocation.z-precisionHalfWidth+wHalfHeight)/AIControl.Pathfinding.Settings.Precision)+1
								)
								local pathfindingStart = AIControl.Pathfinding.FindClosestUnobstructedPoint(
									math.floor((pos.x-precisionHalfWidth+wHalfWidth)/AIControl.Pathfinding.Settings.Precision)+1,
									math.floor((pos.z-precisionHalfWidth+wHalfHeight)/AIControl.Pathfinding.Settings.Precision)+1,
									pathfindingTarget
								)
								
								--print('pathfindingStart: '..pathfindingStart[1]..', '..pathfindingStart[2])
								--print('pathfindingTarget: '..pathfindingTarget[1]..', '..pathfindingTarget[2])
								local path = AIControl.Pathfinding.GetPath(pathfindingStart, pathfindingTarget)
								
								if path then
									
									--print('got a path')
									--AIControl.Pathfinding.DebugPrint(path)
									
									--local skipped = 0
									local queued = false
									for i,v in pairs(path) do
										--if i ~= table.getn(path) and skipped < 2 then
										--	skipped = skipped + 1
										--else
										--	skipped = 0
											Cmd_Move(
												sg,
												Util_ScarPos(
													v[1]*AIControl.Pathfinding.Settings.Precision - precisionHalfWidth - wHalfWidth,
													v[2]*AIControl.Pathfinding.Settings.Precision - precisionHalfWidth - wHalfHeight
												),
												queued
											)
											queued = true
										--end
									end
								end
							else
								Cmd_Stop(sg)
								lockSquad = false
							end
						else
							lockSquad = false
						end
					end
					
					if not lockSquad then
						local angleThreshold
						
						-- Rotate if facing badly
						if table.getn(surroundingSafety) > 0 and surroundingSafety[1][3] > 0.15 then
							angleThreshold = 30
							
							local highestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[1][1] ][ surroundingSafety[1][2] ][enemyTeam]
							local highestDangerDirection = normalizeVector(Util_ScarPos(
								highestDangerPosition.x - pos.x,
								highestDangerPosition.z - pos.z
							))
							
							retreatDirection = normalizeVector(Util_ScarPos(
								highestDangerDirection.x-directionToHq.x*0.5,
								highestDangerDirection.z-directionToHq.z*0.5
							))
						else
							angleThreshold = 170
							
							retreatDirection = Util_ScarPos(-directionToHq.x, -directionToHq.z)
						end
						
						local heading = Squad_GetHeading(squad)
						
						local angle = math.acos(
							(retreatDirection.x*heading.x+retreatDirection.z*heading.z) /
							(math.sqrt(retreatDirection.x*retreatDirection.x + retreatDirection.z*retreatDirection.z) * math.sqrt(heading.x*heading.x + heading.z*heading.z))
						)
						
						--print(string.format("  Angle diff: %.2f Threshold: %.2f", angle*180/3.14, angleThreshold))
						if angle > angleThreshold/180*3.14 then
							lockSquad = true
							
							if not AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] or AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] > 10 then
								--print("  ROTATING BADLY FACING TANK!")
								AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = 0
								Command_SquadPosFacing(player, sg, SCMD_Move, pos, Util_ScarPos(pos.x + retreatDirection.x*10, pos.z + retreatDirection.z*10), false)
							else
								AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
							end
						else
							if AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] and AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] <= 10 then
								AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
							else
								AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = nil
							end
						end
						
					end
					
					if lockSquad then
						if not AIControl.MainControl.LockedSquads[team][squadGameID] then
							AIControl.MainControl.LockedSquads[team][squadGameID] = true
							if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
								AI_LockSquad(player, squad)
							end
						end
					elseif AIControl.MainControl.LockedSquads[team][squadGameID] then
						AIControl.MainControl.LockedSquads[team][squadGameID] = nil
						if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
							AI_UnlockSquad(player, squad)
						end
					end
				end
			end
			SGroup_Destroy(sg)
		end
	end,

	SecondaryUpdate = function()
		-- Find all controlled squads
		SGroup_Clear(AIControl.MainControl.Vehicles[1])
		SGroup_Clear(AIControl.MainControl.Vehicles[2])
		SGroup_Clear(AIControl.MainControl.UnitControls[1])
		SGroup_Clear(AIControl.MainControl.UnitControls[2])
		for i=1,AIControl.PlayerCount do
			local player = World_GetPlayerAt(AIControl.Players[i])
			local team = Player_GetTeam(player)+1
			local squads = Player_GetSquads(player)
			for j=1,SGroup_CountSpawned(squads) do
				local s = SGroup_GetSpawnedSquadAt(squads, j)
				
				local sbp = Squad_GetBlueprint(s)
				local raceStr = Player_GetRaceName(player)
				local bpid = BP_GetID(sbp)
				if AIControl.MainControl.Settings.UnitControl.UnitSettings[raceStr] and AIControl.MainControl.Settings.UnitControl.UnitSettings[raceStr][bpid] then -- unit control
					SGroup_Add(AIControl.MainControl.UnitControls[team], s)
				else
					local exclude = AIControl.MainControl.Settings.VehicleControl.ExcludeFromControl[raceStr] and AIControl.MainControl.Settings.VehicleControl.ExcludeFromControl[raceStr][bpid]
					if not exclude and Squad_GetMax(s) == 1 and Squad_GetHealthMax(s) > 200 then -- vehicle control
						SGroup_Add(AIControl.MainControl.Vehicles[team], s)
					end
				end
			end
		end
	end,
}
