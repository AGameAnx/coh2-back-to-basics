
--string.lpad = function(str, len, char)
--	if char == nil then char = ' ' end
--	return string.rep(char, len - string.len(str))..str
--end

if not g_AIControl_Enable then
	
g_AIControl_Enable = true
g_AIControl_Pause = false

local abs = math.abs
local min = math.min
local max = math.max
local ceil = math.ceil
local floor = math.floor
local sqrt = math.sqrt
local sort = table.sort

function AIControl_IsSquadVehicle(squad)
	return Squad_GetMax(squad) == 1 and Entity_IsVehicle(Squad_EntityAt(squad, 0))
end

g_AIControl_Components = {
	RETREAT = true,
	REINFORCING = true,
	VEHICLE_CONTROL = true,
	VEHICLE_CONTROL_RETREAT = true,
	COMBATUNIT_CONTROL = true,
	COMBATUNIT_CONTROL_ABILITIES = true,
	COMBATUNIT_CONTROL_HELP = false,
	COMBATUNIT_CONTROL_ASSAULT = true,
	COMBATUNIT_CONTROL_TAKECOVER = false,
	UNIT_CONTROL = true,
	UNIT_CONTROL_RETREAT = true,
	BARRAGE_CONTROL = true,
}

local AIControl_Grid
local AIControl_Grid_Settings
local Dimensions

local AIControl_Grid_DataHistory
local AIControl_Grid_t_DataHistory

local AIControl_Grid_DataClump
local AIControl_Grid_DataClumpFOW

--local AIControl_Grid_DataSquads
--local AIControl_Grid_t_DataSquads
local AIControl_Grid_DataCounts
local AIControl_Grid_t_DataCounts
local AIControl_Grid_Data
local AIControl_Grid_t_Data
local AIControl_Grid_ArmorData
local AIControl_Grid_t_ArmorData
local AIControl_Grid_AveragePosData
local AIControl_Grid_t_AveragePosData

local AIControl_MainControl
local AIControl_MainControl_Settings
local AIControl_MainControl_Settings_UnitControl
local AIControl_MainControl_Settings_VehicleControl
local AIControl_MainControl_Settings_BarrageControl
local AIControl_MainControl_Settings_CombatUnitControl
local AIControl_MainControl_LockedSquads

local wHalfWidth = World_GetWidth()*0.5
local wHalfHeight = World_GetLength()*0.5

local AIControl = {}

local AIControl_Players = {}
local AIControl_PlayerCount = 0

AIControl.Grid = {
	Settings = {
		SplitUpdates = true, -- If true, the update will be split to be performed over the course of UpdateInterval rather than once per UpdateInterval
		SplitUpdateIncreasePerSquadCount = 3,
		
		-- These settings will only be used on game start, changing them later on will not affect the actual values
		Init_Dimensions = {11, 11}, -- Initial dimensions table
		
		AutoDimensionsEnable = true, -- if this is enabled, world will automatically be divided into areas with dimensions closest to supplied dimensions table
		                             -- Otherwise, init dimensions will be used directly to divide map into that many parts
		HistoryGrowthModifier = 0.775, -- Higher modifiers mean faster growth and higher max history values
		HistoryDecrementPerTick = 0.0015, --
		ExcludedUnits = {},
	},
	
	Dimensions = {0, 0, 1, 1}, -- {x divisions, y divisions, cell width, cell height}
	
	DataClump = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat combined with nearby cell threat without cells hidden in FOW
	DataClumpFOW = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat combined with nearby cell threat with cells hidden in FOW and additional weight for history
	
	t_DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	--t_DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell
	--DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell
	t_DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell
	DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell
	t_Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell
	Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell
	t_ArmorData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit min armor for each cell
	ArmorData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit min armor for each cell
	t_PenetrationData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit penetration for each cell
	PenetrationData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit penetration for each cell
	t_AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell
	AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell
	
	SplitUpdateCount = 1,
	SplitUpdateStep = 0,
	SplitUpdateSquads = {},
	
	SetDimensions = function(x, y, auto)
		local worldWidth, worldLength = World_GetWidth(), World_GetLength()
		if auto == nil then auto = AIControl_Grid_Settings.AutoDimensionsEnable end
		if auto then
			Dimensions[1] = floor(worldWidth/x)
			Dimensions[2] = floor(worldLength/y)
		else
			Dimensions[1] = x
			Dimensions[2] = y
		end
		Dimensions[3] = worldWidth/Dimensions[1]
		Dimensions[4] = worldLength/Dimensions[2]
		--print("Dimensions: "..Dimensions[1].."*"..Dimensions[3].." x "..Dimensions[2].."*"..Dimensions[4])
		AIControl_Grid_DataHistory = {}
		AIControl_Grid_t_DataHistory = {}
		--AIControl_Grid_DataSquads = {}
		for i=1,Dimensions[1] do
			AIControl_Grid_DataHistory[i] = {}
			AIControl_Grid_t_DataHistory[i] = {}
			--AIControl_Grid_DataSquads[i] = {}
			for j=1,Dimensions[2] do
				AIControl_Grid_DataHistory[i][j] = {0, 0}
				AIControl_Grid_t_DataHistory[i][j] = {0, 0}
				--AIControl_Grid_DataSquads[i][j] = {{}, {}}
			end
		end
	end,
	ResetData = function(resetReal)
		if resetReal == nil then resetReal = false end
		for i=1,Dimensions[1] do
			if resetReal then
				AIControl_Grid_DataHistory[i] = {}
				AIControl_Grid_Data[i] = {}
				AIControl_Grid_DataCounts[i] = {}
				AIControl_Grid_AveragePosData[i] = {}
				AIControl_Grid_ArmorData[i] = {}
				AIControl_Grid.PenetrationData[i] = {}
				
				AIControl_Grid_DataClump[i] = {}
				AIControl_Grid_DataClumpFOW[i] = {}
				
				for j=1,Dimensions[2] do
					AIControl_Grid_DataHistory[i][j] = {0, 0}
					AIControl_Grid_Data[i][j] = {0, 0}
					AIControl_Grid_DataCounts[i][j] = {0, 0}
					AIControl_Grid_ArmorData[i][j] = {0, 0}
					AIControl_Grid.PenetrationData[i][j] = {0, 0}
					--AIControl_Grid_DataSquads[i][j] = {{}, {}}
					AIControl_Grid_AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
					
					AIControl_Grid_DataClump[i][j] = {0, 0}
					AIControl_Grid_DataClumpFOW[i][j] = {0, 0}
					
				end
			end
			AIControl_Grid_t_DataHistory[i] = {}
			AIControl_Grid_t_Data[i] = {}
			AIControl_Grid_t_DataCounts[i] = {}
			AIControl_Grid_t_AveragePosData[i] = {}
			AIControl_Grid_t_ArmorData[i] = {}
			AIControl_Grid.t_PenetrationData[i] = {}
			for j=1,Dimensions[2] do
				AIControl_Grid_t_DataHistory[i][j] = {0, 0}
				AIControl_Grid_t_Data[i][j] = {0, 0}
				AIControl_Grid_t_DataCounts[i][j] = {0, 0}
				AIControl_Grid_t_ArmorData[i][j] = {0, 0}
				AIControl_Grid.t_PenetrationData[i][j] = {0, 0}
				--AIControl_Grid_t_DataSquads[i][j] = {{}, {}}
				AIControl_Grid_t_AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
			end
		end
	end,
	
	GetXY = function(pos)
		local x = floor((pos.x+wHalfWidth)/Dimensions[3])+1
		local y = floor((pos.z+wHalfHeight)/Dimensions[4])+1
		if x < 1 then
			x = 1
		elseif x > Dimensions[1] then
			x = Dimensions[1]
		end
		if y < 1 then
			y = 1
		elseif y > Dimensions[2] then
			y = Dimensions[2]
		end
		return x, y
	end,
	UpdateAIPlayers = function() -- returns squad counts
		AIControl_PlayerCount = 0
		AIControl_Players = {}
		local squadCounts = {0, 0}
		for i=1,World_GetPlayerCount() do
			local player = World_GetPlayerAt(i)
			if not Player_IsHuman(player) then
				AIControl_PlayerCount = AIControl_PlayerCount + 1
				AIControl_Players[AIControl_PlayerCount] = i
			end
			local team = Player_GetTeam(player)+1
			if team == 1 or team == 2 then
				squadCounts[team] = squadCounts[team] + SGroup_CountSpawned(Player_GetSquads(player))
			end
		end
		return squadCounts
	end,
	Update = function()
		if g_AIControl_Pause then return end
		
		local squadCounts = AIControl_Grid.UpdateAIPlayers()
		if not AIControl_Grid_Settings.SplitUpdates or AIControl_Grid.SplitUpdateStep == 0 then
			--dr_clear('aicontrol_maincontrol')
			--dr_clear("aicontrol_grid")
			AIControl_Grid.ResetData(false)
			for i=1,Dimensions[1] do
				for j=1,Dimensions[2] do
					AIControl_Grid_t_AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
					for team=1,2 do
						if squadCounts[team] > 0 then
							AIControl_Grid_DataHistory[i][j][team] = max(0,
								AIControl_Grid_DataHistory[i][j][team]
								- max(0, AIControl_Grid_Settings.HistoryDecrementPerTick)
								- (max(1, AIControl_Grid_DataHistory[i][j][team]*0.05)^2)/max(1, squadCounts[team])
								)
							AIControl_Grid_t_DataHistory[i][j][team] = AIControl_Grid_DataHistory[i][j][team]
						end
					end
				end
			end
			
			if AIControl_Grid.SplitUpdateStep == 0 then
				AIControl_Grid.SplitUpdateSquads = {}
				
				local allSquads = {}
				local sqCount = 0
				for i=1,World_GetPlayerCount() do
					local player = World_GetPlayerAt(i)
					local team = Player_GetTeam(player)+1
					if team == 1 or team == 2 then
						local pSquads = Player_GetSquads(player)
						for j=1,SGroup_CountSpawned(pSquads) do
							sqCount = sqCount + 1
							allSquads[sqCount] = SGroup_GetSpawnedSquadAt(pSquads, j)
						end
					end
				end
				
				AIControl_Grid.SplitUpdateCount = max(8, ceil(sqCount / AIControl_Grid_Settings.SplitUpdateIncreasePerSquadCount))
				
				for i=1,AIControl_Grid.SplitUpdateCount do
					AIControl_Grid.SplitUpdateSquads[i] = SGroup_CreateIfNotFound("sg_aicontrol_splitupdatesquads_"..i)
					SGroup_Clear(AIControl_Grid.SplitUpdateSquads[i])
				end
				
				local curUpdateIndex = 1
				for i=1,sqCount do
					SGroup_Add(AIControl_Grid.SplitUpdateSquads[curUpdateIndex], allSquads[i])
					curUpdateIndex = curUpdateIndex + 1
					if curUpdateIndex > AIControl_Grid.SplitUpdateCount then
						curUpdateIndex = 1
					end
				end
				
				--[[local sqPerStep = AIControl_Grid_Settings.SplitUpdateIncreasePerSquadCount
				for i=1,AIControl_Grid.SplitUpdateCount do
					AIControl_Grid.SplitUpdateSquads[i] = SGroup_CreateIfNotFound("sg_aicontrol_splitupdatesquads_"..i)
					SGroup_Clear(AIControl_Grid.SplitUpdateSquads[i])
					if sqCount >= AIControl_Grid.SplitUpdateCount or i <= sqCount then
						for j=(i-1)*sqPerStep+1,min(sqCount, i*sqPerStep) do
							if allSquads[j] then
								SGroup_Add(AIControl_Grid.SplitUpdateSquads[i], allSquads[j])
							end
						end
					end
				end]]
			end
		end
		
		local squads
		if AIControl_Grid_Settings.SplitUpdates then
			AIControl_Grid.SplitUpdateStep = AIControl_Grid.SplitUpdateStep + 1
			squads = AIControl_Grid.SplitUpdateSquads[AIControl_Grid.SplitUpdateStep]
			if AIControl_Grid.SplitUpdateStep >= AIControl_Grid.SplitUpdateCount then
				AIControl_Grid.SplitUpdateStep = 0
			end
		else
			squads = SGroup_CreateIfNotFound("sg_temp_aicontrol_squads")
			for i=1,World_GetPlayerCount() do
				local player = World_GetPlayerAt(i)
				local team = Player_GetTeam(player)+1
				if team == 1 or team == 2 then
					local pSquads = Player_GetSquads(player)
					for j=1,SGroup_CountSpawned(pSquads) do
						local s = SGroup_GetSpawnedSquadAt(pSquads, j)
						SGroup_Add(squads, s)
					end
				end
			end
		end
		for i=1,SGroup_CountSpawned(squads) do
			local s = SGroup_GetSpawnedSquadAt(squads, i)
			local squadGameID = Squad_GetGameID(s)
			local sbp = removeModID(BP_GetName(Squad_GetBlueprint(s)))
			local player = Squad_GetPlayerOwner(s)
			local team = Player_GetTeam(player)+1
			local enemyTeam = Team_GetEnemyTeam(team-1)+1
			local position = Squad_GetPosition(s)
			local x,y = AIControl_Grid.GetXY(position)
			
			local retreated = Squad_IsRetreating(s)
			if not Player_IsHuman(player) and not retreated then
				
				-- retreating
				if g_AIControl_Components.RETREAT then
					if Squad_IsUnderAttack(s, 2) and not Squad_IsRetreating(s) and not AIControl_IsSquadVehicle(s) then
						local retreatDemand = AIControl_MainControl.RetreatTactic(s)
						if retreatDemand > 0 then
							--local r = World_GetRand(0, 20)/10
							--if r <= retreatDemand then
								retreated = true
								
								local retreatSG = SGroup_CreateIfNotFound('BtB_retreat')
								SGroup_Clear(retreatSG)
								SGroup_Add(retreatSG, s)
								if Squad_IsInHoldEntity(s) then -- eject squads in entity hold
									local holdEntity = Squad_GetHoldEntity(s)
									local tmpEG = EGroup_CreateIfNotFound('BtB_tmp')
									EGroup_Clear(tmpEG)
									EGroup_Add(tmpEG, holdEntity)
									Cmd_EjectOccupants(tmpEG)
									EGroup_Destroy(tmpEG)
									Cmd_Retreat(retreatSG, nil, nil, true) -- queued retreat
								elseif Squad_IsInHoldSquad(s) then -- eject squads in s hold
									local holdSquad = Squad_GetHoldSquad(s)
									local tmpSG = SGroup_CreateIfNotFound('BtB_tmp')
									SGroup_Clear(tmpSG)
									SGroup_Add(tmpSG, holdSquad)
									Cmd_EjectOccupants(tmpSG)
									SGroup_Destroy(tmpSG)
									Cmd_Retreat(retreatSG, nil, nil, true) -- queued retreat
								else
									Cmd_Retreat(retreatSG)
								end
								SGroup_Destroy(retreatSG)
							--end
						end
					end
				end
				
				if not retreated then
					
					-- reinforcing
					if g_AIControl_Components.REINFORCING then
						local tmpSG = SGroup_CreateIfNotFound("tempsg")
						SGroup_Single(tmpSG, s)
						if Squad_CanInstantReinforceNow(s) then
							if not Squad_IsReinforcing(s) or Squad_GetProductionQueueSize(s) < 2 then
								Cmd_ReinforceUnit(tmpSG, 1)
							end
						end
						SGroup_Destroy(tmpSG)
					end
					
					local raceStr = Player_GetRaceName(player)
					local ucSetting = AIControl_MainControl_Settings_UnitControl.UnitSettings[sbp]
					local vcUnit = false
					local isVehicle = false
					if ucSetting then -- unit control
						if g_AIControl_Components.UNIT_CONTROL then
							AIControl_MainControl.FUnitControl(s, ucSetting)
						end
					else
						local excludeFromVehicleControl = AIControl_MainControl_Settings_VehicleControl.ExcludeFromControl[raceStr] and AIControl_MainControl_Settings_VehicleControl.ExcludeFromControl[raceStr][sbp]
						isVehicle = AIControl_IsSquadVehicle(s)
						if not excludeFromVehicleControl and isVehicle then -- vehicle control
							vcUnit = true
							if g_AIControl_Components.VEHICLE_CONTROL then
								AIControl_MainControl.FVehicleControl(s)
							end
						end
					end
					local bcSetting = AIControl_MainControl_Settings_BarrageControl.UnitSettings[sbp]
					if bcSetting then
						if g_AIControl_Components.BARRAGE_CONTROL then
							AIControl_MainControl.FBarrageControl(s, bcSetting)
						end
					end
					if g_AIControl_Components.COMBATUNIT_CONTROL and not ucSetting and not vcUnit and not bcSetting and not isVehicle then
						local squadGameID = Squad_GetGameID(s)
						if
								not AIControl_MainControl_LockedSquads[team][squadGameID]
								or AIControl_MainControl_LockedSquads[team][squadGameID] == -1
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 6 then
							local inCombat = Squad_IsAttacking(s, 5) or Squad_IsUnderAttack(s, 5)
							if
									inCombat
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 6 then
								AIControl_MainControl.FCombatUnitControl(s, inCombat)
							end
						end
					end
				end
			end
			
			if not AIControl_Grid_Settings.ExcludedUnits[sbp] then
				local squadWeight = 1
				local squadHealthMax = Squad_GetHealthMax(s)
				local squadHealth = Squad_GetHealth(s)
				
				if Squad_GetMax(s) == 1 then
					if Entity_IsPlane(Squad_EntityAt(s, 0)) then
						squadWeight = 0
					else
						if squadHealthMax > 200 then
							squadWeight = squadHealthMax/(50+(squadHealthMax-200)/10)/3 + squadHealth/(50+(squadHealth-200)/10)/3*2
						else
							squadWeight = squadHealthMax*0.02*(1/3) + squadHealth*0.04*(1/3)
						end
						if Squad_GetMinArmor(s) > 1 then
							squadWeight = squadWeight * (1 + Squad_GetMinArmor(s)/70)
						end
					end
				elseif Squad_Count(s) > 0 then
					squadWeight = Squad_Count(s)*0.5+squadHealthMax/150*(1/3)+squadHealth/150*(1/3)*2
				end
				if Squad_IsRetreating(s) then
					squadWeight = squadWeight*(1/4)
				end
				
				AIControl_Grid_t_Data[x][y][team] = AIControl_Grid_t_Data[x][y][team] + squadWeight
				AIControl_Grid_t_DataCounts[x][y][team] = AIControl_Grid_t_DataCounts[x][y][team] + 1
				AIControl.Grid.t_ArmorData[x][y][team] = AIControl.Grid.t_ArmorData[x][y][team] + Squad_GetMinArmor(s)
				AIControl_Grid_t_DataHistory[x][y][team] = AIControl_Grid_t_DataHistory[x][y][team] + squadWeight/max(squadCounts[team])*AIControl_Grid_Settings.HistoryGrowthModifier
				--SGroup_Add(AIControl_Grid_t_DataSquads[x][y][team], s)
				
				AIControl_Grid_t_AveragePosData[x][y][team].x = AIControl_Grid_t_AveragePosData[x][y][team].x + position.x
				AIControl_Grid_t_AveragePosData[x][y][team].y = AIControl_Grid_t_AveragePosData[x][y][team].y + position.y
				AIControl_Grid_t_AveragePosData[x][y][team].z = AIControl_Grid_t_AveragePosData[x][y][team].z + position.z
			end
		end
		SGroup_Destroy(squads)
		
		if not AIControl_Grid_Settings.SplitUpdates or AIControl_Grid.SplitUpdateStep == 0 then
			for i=1,Dimensions[1] do
				for j=1,Dimensions[2] do
					for team=1,2 do
						AIControl_Grid_DataCounts[i][j][team] = AIControl_Grid_t_DataCounts[i][j][team]
						
						--SGroup_Clear(AIControl_Grid_DataSquads[i][j][team])
						--for k=1,SGroup_CountSpawned(AIControl_Grid_t_DataSquads[i][j][team]) do
						--	SGroup_Add(AIControl_Grid_DataSquads[i][j][team], SGroup_GetSpawnedSquadAt(AIControl_Grid_t_DataSquads[i][j][team], k))
						--end
						
						AIControl_Grid_Data[i][j][team] = AIControl_Grid_t_Data[i][j][team]
						AIControl_Grid_ArmorData[i][j][team] = AIControl_Grid_t_ArmorData[i][j][team]
						AIControl_Grid_DataHistory[i][j][team] = AIControl_Grid_t_DataHistory[i][j][team]
						if AIControl_Grid_DataCounts[i][j][team] > 0 then
							AIControl_Grid_AveragePosData[i][j][team] = World_Pos(
								AIControl_Grid_t_AveragePosData[i][j][team].x/AIControl_Grid_DataCounts[i][j][team],
								AIControl_Grid_t_AveragePosData[i][j][team].y/AIControl_Grid_DataCounts[i][j][team],
								AIControl_Grid_t_AveragePosData[i][j][team].z/AIControl_Grid_DataCounts[i][j][team])
						else
							AIControl_Grid_AveragePosData[i][j][team] = World_Pos(i*AIControl.Grid.Dimensions[3] - wHalfWidth, 0, j*AIControl.Grid.Dimensions[4] - wHalfHeight)
						end
					end
				end
			end
			
			-- Update clump data
			for team=1,2 do
				local enemyTeam = Team_GetEnemyTeam(team-1)+1
				local player
				for i=1,World_GetPlayerCount() do
					local p = World_GetPlayerAt(i)
					if Player_GetTeam(p)+1 == team then
						player = p
						break
					end
				end
				for i=1,Dimensions[1] do
					for j=1,Dimensions[2] do
						if AIControl_Grid_Data[i][j][enemyTeam] > 0 then
							local canSee = Player_CanSeePosition(player, AIControl_Grid_AveragePosData[i][j][enemyTeam])
							local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({i, j}, 0, 1, team)
							local danger = 0
							local dangerFOW = 0
							for k=1,#surroundingSafety do
								local v = surroundingSafety[k]
								danger = danger + v[3] + v[4]*0.015 - v[5]*0.35
								dangerFOW = dangerFOW - v[5]*0.35
								if canSee then
									dangerFOW = dangerFOW + v[3] + v[4]*0.015
								else
									dangerFOW = dangerFOW + v[3]*0.275 + v[4]*0.175
								end
							end
							AIControl_Grid_DataClumpFOW[i][j][enemyTeam] = dangerFOW
							if canSee then
								AIControl_Grid_DataClump[i][j][enemyTeam] = danger
							else
								AIControl_Grid_DataClump[i][j][enemyTeam] = 0
							end
						else
							AIControl_Grid_DataClump[i][j][enemyTeam] = 0
							AIControl_Grid_DataClumpFOW[i][j][enemyTeam] = 0
						end
					end
				end
			end
			
			--AIControl_Grid.DebugOutput()
			--AIControl_MainControl.Update()
		end
	end,
	DebugOutput = function()
		local function pr(i, j, val1, val2)
			local x = i*Dimensions[3]-wHalfWidth-Dimensions[3]*0.5
			local y = j*Dimensions[4]-wHalfHeight-Dimensions[4]*0.5
			--dr_text3d('aicontrol_grid', x, World_GetHeightAt(x, y)+0.35, y, string.format('%.1f / %.1f', val1, val2), 0, 255, 0)
		end
		for i=1,Dimensions[1] do
			for j=1,Dimensions[2] do
				pr(i, j, AIControl_Grid_Data[i][j][1], AIControl_Grid_Data[i][j][2])
			end
		end
	end
}

--------------------------------------------------------------------------------------------------------------------

local UNIT_CONTROL_CONST = {
	DEFAULT_SETUP_TARGET_DANGER = 2,
	DEFAULT_SAFETY_SEARCH_RADIUS_STEPS = 3,
	DEFAULT_MOVE_BACK_DANGER = 7,
	DEFAULT_RETREAT_DANGER = 16,
}
local UNIT_CONTROL_PRESET = {
	SNIPER = {
		['attack_move_forward'] = true,
		['safety_radius_steps'] = 3,
		['setup_target_danger'] = 0.85,
		['move_back_danger'] = 2.15,
		['retreat_danger'] = 12,
		['init_step'] = 2,
		['step_count'] = 2,
		['target_angle_threshold'] = -1
	},
	MORTAR = {
		['safety_radius_steps'] = 5,
		['setup_target_danger'] = 1,
		['move_back_danger'] = 1,
		['retreat_danger'] = 10,
		['init_step'] = 3,
		['step_count'] = 2,
		['target_angle_threshold'] = -1
	},
	AT_GUN = {
		['targets_armor'] = true,
		['armor_danger_decrease'] = 0.2,
		['armor_danger_decrease_reduction_threshold'] = 200,
		['move_reverse'] = true,
		['search_cover'] = false,
		['safety_radius_steps'] = 5,
		['setup_target_danger'] = 0.5,
		['move_back_danger'] = 1.35,
		['retreat_danger'] = -1,
		['init_step'] = 0,
		['step_count'] = 5,
		['target_angle_threshold'] = 18
	}
}

local HMGBlueprints = {
	['dshk_38_hmg_squad_mp'] = true,
	['m1910_maxim_heavy_machine_gun_squad_mp'] = true,
	
	['mg42_heavy_machine_gun_squad_mp'] = true,
	
	['m2hb_50cal_hmg_squad_mp'] = true,
	
	['mg34_heavy_machine_gun_squad_mp'] = true,
	
	['british_machine_gun_squad_mp'] = true,
}
local EmplacementBlueprints = {
	['fighting_position_mp'] = true,
	['fighting_position_riflemen_mp'] = true,
	['aef_mg_nest'] = true,
	['aef_mg_nest_aef_base'] = true,
	['aef_mg_nest_perimeter_mp'] = true,
	
	['axis_bunker_starting_position_mp'] = true,
	['bunker_mp'] = true,
	
	['machine_gun_nest_mp'] = true,
	
	['bunker_westgerman_mp'] = true,
	['base_flak_gun_mp'] = true,
	['flak_emplacement'] = true,
	['flak_emplacement_base'] = true,
}

local BARRAGE_CONTROL_POSITION
BARRAGE_CONTROL_POSITION = {
	SMOKE_BARRAGE = function(squad, setting, checkForFriendlySquads, distanceInFront, onlyHMGs)
		if checkForFriendlySquads == nil then checkForFriendlySquads = true end
		if distanceInFront == nil then distanceInFront = 10 end
		if onlyHMGs == nil then onlyHMGs = true end
		local player = Squad_GetPlayerOwner(squad)
		local selfPos = Squad_GetPosition(squad)
		
		local closestDist = setting.searchrange+5
		local closestPos = nil
		
		local sg = SGroup_CreateIfNotFound('tactics_infrontofmgpos')
		SGroup_Clear(sg)
		World_GetSquadsNearPoint(player, sg, selfPos, setting.searchrange, OT_Enemy)
		for i=1,SGroup_CountSpawned(sg) do
			local s = SGroup_GetSpawnedSquadAt(sg, i)
			local sbp = removeModID(BP_GetName(Squad_GetBlueprint(s)))
			if not Squad_IsMoving(s) and not Squad_IsRetreating(s) and not Squad_IsSuppressed(s) and not Squad_IsPinned(s) and (not onlyHMGs or HMGBlueprints[sbp]) then
				local heading = false
				for j=0,Squad_Count(s)-1 do
					local e = Squad_EntityAt(s, j)
					if Entity_IsSyncWeapon(e) then
						heading = Entity_GetHeading(e)
						break
					end
				end
				if not heading then
					heading = Squad_GetHeading(s)
				end
				local squadPos = Squad_GetPosition(s)
				local posValid = true
				if checkForFriendlySquads then
					local searchPos = World_Pos(squadPos.x+heading.x*30, squadPos.y, squadPos.z+heading.z*30)
					local sg2 = SGroup_CreateIfNotFound('tactics_infrontofmgpos2')
					World_GetSquadsNearPoint(player, sg2, searchPos, 45, OT_Ally)
					
					posValid = SGroup_CountSpawned(sg2) > 0
					
					SGroup_Destroy(sg2)
				end
				if posValid then
					local pos
					if not onlyHMGs and (AIControl_IsSquadVehicle(s) or Squad_IsInHoldEntity(s) or Squad_IsInHoldSquad(s)) then
						pos = squadPos
					else
						pos = World_Pos(squadPos.x+heading.x*distanceInFront, squadPos.y, squadPos.z+heading.z*distanceInFront)
					end
					local dist = sqrt((selfPos.x - pos.x)^2 + (selfPos.z - pos.z)^2)
					if dist < closestDist then
						closestDist = dist
						closestPos = pos
					end
				end
			end
		end
		SGroup_Destroy(sg)
		
		if closestPos then
			return closestPos
		end
		
		local eg = EGroup_CreateIfNotFound('tactics_infrontofmgpos')
		EGroup_Clear(eg)
		World_GetEntitiesNearPoint(player, eg, selfPos, setting.searchrange, OT_Enemy)
		for i=1,EGroup_CountSpawned(eg) do
			local e = EGroup_GetSpawnedEntityAt(eg, i)
			local ebp = removeModID(BP_GetName(Entity_GetBlueprint(e)))
			if EmplacementBlueprints[ebp] then
				local heading = Entity_GetHeading(e)
				local entityPos = Entity_GetPosition(e)
				local dist = sqrt((selfPos.x - entityPos.x)^2 + (selfPos.z - entityPos.z)^2)
				if dist < closestDist then
					closestDist = dist
					closestPos = entityPos
				end
			end
		end
		EGroup_Destroy(eg)
		
		if closestPos then
			return closestPos
		end
		return false
	end,
}

local CUCONTROL_TACTIC
local CUCONTROL_ABILITY_PRESET
local CUCONTROL_BEHAVIORS

CUCONTROL_TACTIC = {
	FILTER = {
		
	},
	POSITION_FILTER = {
		GRENADE = function(squad, custom_range, custom_starting_position)
			local range = custom_range or 30
			local selfPos = custom_starting_position or Squad_GetPosition(squad)
			local sg = SGroup_CreateIfNotFound('tactics_grenadepos')
			SGroup_Clear(sg)
			World_GetSquadsNearPoint(Squad_GetPlayerOwner(squad), sg, selfPos, range, OT_Enemy)
			local closestDist = range+5
			local closestSquad = nil
			for i=1,SGroup_CountSpawned(sg) do
				local s = SGroup_GetSpawnedSquadAt(sg, i)
				local isVehicle = false
				for j=0,Squad_Count(s)-1 do
					local entity = Squad_EntityAt(s, j)
					if Entity_IsVehicle(entity) then
						isVehicle = true
						break
					end
				end
				if not isVehicle and not Squad_IsMoving(s) then
					local pos = Squad_GetPosition(s)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestSquad = s
					end
				end
			end
			SGroup_Destroy(sg)
			if closestSquad then
				return Squad_GetPosition(closestSquad)
			else
				return false
			end
		end,
		SMOKE_GRENADE = function(squad)
			return BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE(squad, {searchrange = 50}, false, 15, false)
		end,
	},
	SQUAD_FILTER = {
		
	},
	POSITION_VERIFY = {
		GRENADE = function(squad, position1, position2)
			local pos = CUCONTROL_TACTIC.POSITION_FILTER.GRENADE(squad, 5, position1)
			return pos and World_DistancePointToPoint(position1, pos) < 7
		end,
	}
}

CUCONTROL_ABILITY_PRESET = {
	GRENADE = {
		blueprint = BP_GetAbilityBlueprint('mk2_fragmentation_grenade_mp'),
		lockDuration = 15,
		verifyPosition = true,
		weight = 10,
		queued = false,
		type = 'targeted',
		--filter = CUCONTROL_TACTIC.FILTER.TRIVIAL_ACCEPT,
		position = CUCONTROL_TACTIC.POSITION_FILTER.GRENADE,
		positionVerify = CUCONTROL_TACTIC.POSITION_VERIFY.GRENADE
	},
	SMOKE_GRENADE = {
		blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_mp'),
		lockDuration = 15,
		verifyPosition = false,
		weight = 10,
		queued = false,
		type = 'targeted',
		position = CUCONTROL_TACTIC.POSITION_FILTER.SMOKE_GRENADE,
	},
}

CUCONTROL_BEHAVIORS = {
	FIRE_UP = function(squad, callback)
		--Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/ally_fireup_ability.lua'), nil, nil, false, false)
		callback()
	end,
}

AIControl.MainControl = {
	Settings = {
		RetreatTactic_BaseSafety = 0.85, -- Higher value means higher danger is required for a squad to retreat
		RetreatTactic_BattleRadius = 50, -- How far do we search for enemy squads when considering retreat
		
		--AIMarkerToSpawn = BP_GetEntityBlueprint('high'),
		
		UnitControl = {
			UnitSettings = {
				-- Soviet
				['dshk_38_hmg_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 3,
					['target_angle_threshold'] = 18
				},
				['m1910_maxim_heavy_machine_gun_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 3,
					['target_angle_threshold'] = 18
				},
				['sniper_team_mp'] = UNIT_CONTROL_PRESET.SNIPER,
				['pm-82_41_mortar_squad_mp'] = UNIT_CONTROL_PRESET.MORTAR,
				['hm-120_38_mortar_squad_mp'] = UNIT_CONTROL_PRESET.MORTAR,
				['m1937_53-k_45mm_at_gun_squad_mp'] = UNIT_CONTROL_PRESET.AT_GUN,
				['m1942_zis-3_76mm_at_gun_squad_mp'] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- Ostheer
				['mg42_heavy_machine_gun_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				['sniper_squad_mp'] = UNIT_CONTROL_PRESET.SNIPER,
				['mortar_team_81mm_mp'] = UNIT_CONTROL_PRESET.MORTAR,
				['pak40_75mm_at_gun_squad_mp'] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- USF
				['m2hb_50cal_hmg_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 28
				},
				['m1_75mm_pack_howitzer_squad_mp'] = UNIT_CONTROL_PRESET.MORTAR,
				['m1_57mm_at_gun_squad_mp'] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- OKW
				['mg34_heavy_machine_gun_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				['raketenwerfer43_88mm_puppchen_antitank_gun_squad_mp'] = {
					['targets_armor'] = true,
					['armor_danger_decrease'] = 0.15,
					['armor_danger_decrease_reduction_threshold'] = 200,
					['move_reverse'] = true,
					['search_cover'] = false,
					['safety_radius_steps'] = 5,
					['setup_target_danger'] = 1.5,
					['move_back_danger'] = 9,
					['retreat_danger'] = 15,
					['init_step'] = 2,
					['step_count'] = 4,
					['target_angle_threshold'] = 18
				},
				['le_ig_18_inf_support_gun_squad_mp'] = UNIT_CONTROL_PRESET.MORTAR,
				
				-- British
				['british_machine_gun_squad_mp'] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				['sniper_british_squad_mp'] = UNIT_CONTROL_PRESET.SNIPER,
				['brit_6_pounder_at_gun_squad_mp'] = UNIT_CONTROL_PRESET.AT_GUN,
			},
			
			HistoryMultiplier = 0.003, --
			CoverSearchRadius = 7, -- how far do we search for cover
		},
		
		VehicleControl = {
			DefaultBaseDangerRequiredToRetreat = 70,
			DefaultDangerRequiredDecreaseWithHealth = 85,
			DefaultDangerRequiredDecreaseWithFriendlyArmor = 0.1,
			DangerRequiredToRetreatDecreaseForLightVehicles = 50,
			DangerRequiredToRetreatIncreaseNearHQ = 50,
			ReverseThreshold = 90,
			DecrewCritical = BP_GetCriticalBlueprint('vehicle_decrew'), -- required to decrew tanks that have retreated to repair and are in safety
			CustomVehicles = { -- {base danger requirement to retreat, danger requirement decrease with health}
				['soviet'] = {
					['su-85_mp'] = {20, 60, 80},
					['katyusha_bm-13n_squad'] = {2, 2, 0},
					['katyusha_bm-13n_squad_mp'] = {2, 2, 0},
				},
				['german'] = {
					['panzerwerfer_squad'] = {2, 2},
					['panzerwerfer_squad_mp'] = {2, 2},
					['sdkfz_251_halftrack_squad_mp'] = {30, 55, 0},
				},
				['aef'] = {
					['dodge_wc51_ambulance_squad_mp'] = {2, 2},
					['m15a1_aa_halftrack_squad_mp'] = {nil, nil, 0, true},
				},
				['west_german'] = {
					['sdkfz_251_wurfrahmen_40_halftrack_squad_mp'] = {3, 3},
				},
				['british'] = {
					['sexton_spg_squad_mp'] = {3, 3},
				},
			},
			DisableCriticals = {
				BP_GetCriticalBlueprint('critical/vehicle_stuck_in_mud.lua'),
			},
			DamageCriticals = {
				BP_GetCriticalBlueprint('critical/vehicle_light_destroy_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_light_destroy_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_engine_rear.lua'),
				
				BP_GetCriticalBlueprint('critical/vehicle_light_damage_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_light_damage_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_rear_ramming.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_incremental.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_maingun.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_maingun_ramming.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_quad_50.lua'),
			},
			ExcludeFromControl = {
				['soviet'] = {
					
				},
				['german'] = {
					
				},
				['aef'] = {
					
				},
				['west_german'] = {
					['sws_halftrack_squad_sp'] = true,
					['sws_halftrack_squad_mp'] = true,
				},
				['british'] = {
				
				},
			}
		},
		
		BarrageControl = { -- Normal ai tactic functionality should be used for most barrages. These barrages are included here mostly to fix the units locked due to other aicontrol functionality
			SaveUpAmountGrowthWithTime = 0/700, -- Munitions saved starts at 0 and grows throughout the game
			SaveUpAmount = 0, -- We'll try to save up to this amount of munitions in the lategame
			ChanceToCastBelowsavedMunitionsThreshold = 100, -- A percentage chance to cast the abilities even if we're currently saving up our munitions
			UnitSettings = {
				['pm-82_41_mortar_squad_mp'] = {
					{weight=2, searchrange=90, cost=0, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=8, blueprint=BP_GetAbilityBlueprint('smoke_sync_mortar_barrage_mp')},
					{weight=4, searchrange=90, cost=0, minThreatToCast=1.35, lockDuration=8, blueprint=BP_GetAbilityBlueprint('sync_mortar_barrage_mp')},
				},
				['mortar_team_81mm_mp'] = {
					{weight=2, searchrange=90, cost=0, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=8, blueprint=BP_GetAbilityBlueprint('mortar_team_smoke_barrage_mp')},
					{weight=4, searchrange=90, cost=0, minThreatToCast=1.35, lockDuration=8, blueprint=BP_GetAbilityBlueprint('mortar_team_mortar_barrage_mp')},
				},
			},
		},
		
		CombatUnitControl = {
			BaseLockChance = 20,
			DefaultAbilityChance = 40,
			HelpRadius = 55,
			DefaultCloseInDistance = 10,
			UnitSettings = {
				-- Soviet
				['shock_troops_mp'] = {
					assault_troops = true,
					ability_chance = 100,
					lock_chance = 100,
					abilities = {
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('rgd_1_smoke_grenade_mp')}},
					},
				},
				
				-- Ostheer
				['panzer_grenadier_squad_mp'] = {
					assault_troops = true,
					lock_chance = 100,
					close_in_distance = 20,
				},
				
				-- USF
				['riflemen_squad_mp'] = {
					assault_troops = function(squad) return Squad_HasSlotItem(squad, BP_GetSlotItemBlueprint('riflemen_m1918_bar_mp')) end,
					abilities = {
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_mp')}},
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_vet_mp')}},
					},
				},
				['riflemen_squad_veteran_mp'] = {
					assault_troops = function(squad) return Squad_HasSlotItem(squad, BP_GetSlotItemBlueprint('riflemen_m1918_bar_mp')) end,
					abilities = {
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_mp')}},
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_vet_mp')}},
					},
				},
				['lieutenant_squad_mp'] = {
					assault_troops = function(squad) return Squad_HasSlotItem(squad, BP_GetSlotItemBlueprint('riflemen_m1918_bar_mp')) end,
					lock_chance = 100,
					abilities = {
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_mp')}},
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('m23_smoke_stream_rifle_grenade_vet_mp')}},
					},
				},
				
				-- OKW
				['assault_pioneer_squad_mp'] = {
					assault_troops = true,
					close_in_distance = 17,
					ability_chance = 100,
					abilities = {
						{preset = CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE, overrides = {blueprint = BP_GetAbilityBlueprint('23d6cdb82724460dbcb21e1a9162e473:smoke_grenade_mp')}},
					},
				},
			},
		},
		
		AICheats = {
			ManpowerRate = 1,
			MunitionsRate = 1,
			FuelRate = 1,
			CommandPointRate = 1.2,
			
			Popcap = 160,
			StartingResources = 1.35,
			ExperienceReceived = 1.15,
			ProductionRate = 1.5,
			Upkeep = 0.825,
			SightRadius = 1,
		},
	},
	
	-- SGroups
	AICheatModifiers = {},
	LockedSquads = {{}, {}},
	
	UnitControlTargets = {{}, {}},
	UnitControlUnlockTimers = {{}, {}},
	UnitControlIdleTimers = {{}, {}},
	
	BarrageControlLockTimers = {},
	CombatUnitControlAbilityLockTimers = {},
	CombatUnitControlHelpLockTimers = {},
	
	VehicleControl = {
		RepairsRetreat = {{}, {}},
		FacingCmdTimers = {{}, {}},
		RetreatCmdTimers = {{}, {}},
	},
	
	Init = function()
		AIControl_MainControl.UnitControls = {SGroup_CreateIfNotFound("AIControl_MainControl.TWT1"), SGroup_CreateIfNotFound("AIControl_MainControl.TWT2")}
		AIControl_MainControl.Vehicles = {SGroup_CreateIfNotFound("AIControl_MainControl.VT1"), SGroup_CreateIfNotFound("AIControl_MainControl.VT2")}
		
		for i=1,#AIControl_MainControl.AICheatModifiers do
			Modifier_Remove(AIControl_MainControl.AICheatModifiers[i])
		end
		if AIControl_MainControl_Settings.AICheats.StartingResources ~= 1 then
			for i=1,AIControl_PlayerCount do
				local player = World_GetPlayerAt(AIControl_Players[i])
				Player_SetResource(player, RT_Manpower, Player_GetResource(player, RT_Manpower)*AIControl_MainControl_Settings.AICheats.StartingResources)
				Player_SetResource(player, RT_Fuel, Player_GetResource(player, RT_Fuel)*AIControl_MainControl_Settings.AICheats.StartingResources)
				Player_SetMaxPopulation(player, CT_Personnel, AIControl_MainControl_Settings.AICheats.Popcap)
				Player_SetMaxCapPopulation(player, CT_Personnel, AIControl_MainControl_Settings.AICheats.Popcap)
			end
		end
		AIControl_MainControl.InitUpdateComplete = true
		AIControl_MainControl.AICheatModifiers = {}
		for i=1,AIControl_PlayerCount do
			local player = World_GetPlayerAt(AIControl_Players[i])
			
			if not Player_IsHuman(player) then
				if AIControl_MainControl_Settings.AICheats.ManpowerRate ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerResourceRate(player, RT_Manpower, AIControl_MainControl_Settings.AICheats.ManpowerRate)
				end
				if AIControl_MainControl_Settings.AICheats.MunitionsRate ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerResourceRate(player, RT_Munition, AIControl_MainControl_Settings.AICheats.MunitionsRate)
				end
				if AIControl_MainControl_Settings.AICheats.FuelRate ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerResourceRate(player, RT_Fuel, AIControl_MainControl_Settings.AICheats.FuelRate)
				end
				if AIControl_MainControl_Settings.AICheats.CommandPointRate ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerResourceRate(player, RT_Action, AIControl_MainControl_Settings.AICheats.CommandPointRate)
				end
				
				if AIControl_MainControl_Settings.AICheats.ExperienceReceived ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerExperienceReceived(player, AIControl_MainControl_Settings.AICheats.ExperienceReceived)
				end
				if AIControl_MainControl_Settings.AICheats.ProductionRate ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerProductionRate(player, AIControl_MainControl_Settings.AICheats.ProductionRate)
				end
				if AIControl_MainControl_Settings.AICheats.Upkeep ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_Upkeep(player, AIControl_MainControl_Settings.AICheats.Upkeep)
				end
				if AIControl_MainControl_Settings.AICheats.SightRadius ~= 1 then
					AIControl_MainControl.AICheatModifiers[#AIControl_MainControl.AICheatModifiers+1] = Modify_PlayerSightRadius(player, AIControl_MainControl_Settings.AICheats.SightRadius)
				end
			end
		end
	end,
	
	GetRetreatDirection = function(surroundingSafety, pos, team, dangerMultiplier, safetyMultiplier, directionToHq, hqMultiplier, historyMultiplier, armorDangerMultiplier, armorSafetyMultiplier)
		if not armorDangerMultiplier then armorDangerMultiplier = 0 end
		if not armorSafetyMultiplier then armorSafetyMultiplier = 0 end
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local x,y = AIControl_Grid.GetXY(pos)
		local retreatDirection = Util_ScarPos(
			directionToHq.x*hqMultiplier,
			directionToHq.z*hqMultiplier
		)
		local highestDanger = 5
		local highestSafety = 15
		local highestArmorDanger = 15
		local highestArmorSafety = 15
		for i=1,#surroundingSafety do
			local safety = surroundingSafety[i]
			if safety[3] > highestDanger then
				highestDanger = safety[3]
			end
			if safety[5] > highestSafety then
				highestSafety = safety[5]
			end
			if safety[7] > highestArmorDanger then
				highestArmorDanger = safety[7]
			end
			if safety[8] > highestArmorSafety then
				highestArmorSafety = safety[8]
			end
		end
		for i=1,#surroundingSafety do
			local safety = surroundingSafety[i]
			local dangerPos = AIControl_Grid_AveragePosData[ safety[1] ][ safety[2] ][enemyTeam]
			if dangerPos.x ~= pos.x or dangerPos.z ~= pos.z then
				local dangerDir = normalizeVector(Util_ScarPos(
					dangerPos.x - pos.x,
					dangerPos.z - pos.z
				))
				retreatDirection.x = retreatDirection.x - (
						dangerDir.x * safety[3] +
						dangerDir.x * safety[4] * historyMultiplier
					) * dangerMultiplier / highestDanger - (
						dangerDir.x * safety[7]
					) * armorDangerMultiplier / highestArmorDanger
				retreatDirection.z = retreatDirection.z - (
						dangerDir.z * safety[3] +
						dangerDir.z * safety[4] * historyMultiplier
					) * dangerMultiplier / highestDanger - (
						dangerDir.z * safety[7]
					) * armorDangerMultiplier / highestArmorDanger
			end
			if safety[1] ~= x or safety[2] ~= y then
				local safetyPos = AIControl_Grid_AveragePosData[ safety[1] ][ safety[2] ][team]
				if safetyPos.x ~= pos.x or safetyPos.z ~= pos.z then
					local safetyDir = normalizeVector(Util_ScarPos(
						safetyPos.x - pos.x,
						safetyPos.z - pos.z
					))
					retreatDirection.x = retreatDirection.x + (
							safetyDir.x * safety[5] +
							safetyDir.x * safety[6] * historyMultiplier
						) * safetyMultiplier / highestSafety - (
							safetyDir.x * safety[9]
						) * armorSafetyMultiplier / highestArmorSafety
					retreatDirection.z = retreatDirection.z + (
							safetyDir.z * safety[5] +
							safetyDir.z * safety[6] * historyMultiplier
						) * safetyMultiplier / highestSafety - (
							safetyDir.z * safety[9]
						) * armorSafetyMultiplier / highestArmorSafety
				end
			end
		end
		if sqrt(retreatDirection.x^2 + retreatDirection.z^2) < 0.001 then
			retreatDirection = directionToHq
		else
			retreatDirection = normalizeVector(retreatDirection)
		end
		return retreatDirection
	end,
	GetRetreatLocation = function(pos, retreatDirection, retreatDistance)
		local result = Util_ScarPos(
			pos.x + retreatDirection.x*retreatDistance,
			pos.z + retreatDirection.z*retreatDistance
		)
		if result.x > wHalfWidth-1 then
			result.x = wHalfWidth-1
		elseif result.x < -wHalfWidth+1 then
			result.x = -wHalfWidth+1
		end
		if result.z > wHalfHeight-1 then
			result.z = wHalfHeight-1
		elseif result.z < -wHalfHeight+1 then
			result.z = -wHalfHeight+1
		end
		return result
	end,
	
	GetSafetyData = function(x, y, team) -- returns danger (float), history_danger (float)
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		
		if x >= 1 and x <= Dimensions[1] and y >= 1 and y <= Dimensions[2] then
			return {
				AIControl_Grid_Data[x][y][enemyTeam], -- 1
				AIControl_Grid_DataHistory[x][y][enemyTeam], -- 2
				AIControl_Grid_Data[x][y][team], -- 3
				AIControl_Grid_DataHistory[x][y][team], -- 4
				AIControl_Grid_ArmorData[x][y][enemyTeam], -- 5
				AIControl_Grid.PenetrationData[x][y][enemyTeam], -- 6
				AIControl_Grid_ArmorData[x][y][team], -- 7
				AIControl_Grid.PenetrationData[x][y][team] -- 8
			}
		else
			return {0,0,0,0,0,0,0,0}
		end
	end,
	GetSurroundingSafetyData = function(gridPos, team, distance, maxDistance)
		local safetyData = AIControl_MainControl.GetSafetyData(gridPos[1], gridPos[2], team)
		local distanceMultiplier = min(1, 1.1 - distance/maxDistance)
		return {
			gridPos[1], -- 1
			gridPos[2], -- 2
			safetyData[1] * distanceMultiplier, -- 3
			safetyData[2] * distanceMultiplier, -- 4
			safetyData[3] * distanceMultiplier, -- 5
			safetyData[4] * distanceMultiplier, -- 6
			safetyData[5] * distanceMultiplier, -- 7
			safetyData[6] * distanceMultiplier, -- 8
			safetyData[7] * distanceMultiplier, -- 9
			safetyData[8] * distanceMultiplier -- 10
		}
	end,
	GetSurroundingSafety = function(pos, dist, steps, team)
		local result, resultCount = {}, 0
		
		--[[local gridPos = {
			floor((pos.x+wHalfWidth)/Dimensions[3])+1,
			floor((pos.z+wHalfHeight)/Dimensions[4])+1
		}]]
		
		local maxPointDistance
		if dist == 0 then
			resultCount = resultCount + 1
			result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData(pos, team, 0, 1)
			dist = 1
			maxPointDistance = sqrt((dist+steps)^2+(dist+steps)^2)
		else
			maxPointDistance = sqrt((dist+steps)^2+(dist+steps)^2)
		end
		
		for x = 0,dist+steps do
			local curx
			curx = pos[1]+x
			if curx <= Dimensions[1] then
				for y=0,dist+steps do
					if x > dist or y > dist then
						local pointDistance = sqrt(x^2 + y^2)
						local cury
						cury = pos[2]+y
						if cury <= Dimensions[2] then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
						cury = pos[2]-y
						if cury >= 1 then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
					end
				end
			end
			curx = pos[1]-x
			if curx >= 1 then
				for y=0,dist+steps do
					if x > dist or y > dist then
						local pointDistance = sqrt(x^2 + y^2)
						local cury
						cury = pos[2]+y
						if cury <= Dimensions[2] then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
						cury = pos[2]-y
						if cury >= 1 then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
					end
				end
			end
		end
		return result
	end,
	
	RetreatTactic = function(squad)
		local result = -AIControl_MainControl_Settings.RetreatTactic_BaseSafety
		
		local pos = Squad_GetPosition(squad)
		local p = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(p)
		local enemyTeam = Team_GetEnemyTeam(team)
		local squadsNearSG_enemy = SGroup_CreateIfNotFound("BtB_RetreatTactic_squadsNear_enemy")
		local squadsNearSG_allied = SGroup_CreateIfNotFound("BtB_RetreatTactic_squadsNear_allied")
		SGroup_Clear(squadsNearSG_enemy)
		SGroup_Clear(squadsNearSG_allied)
		Team_GetAllSquadsNearMarker(Team_GetPlayers(enemyTeam), squadsNearSG_enemy , pos, AIControl_MainControl_Settings.RetreatTactic_BattleRadius)
		Team_GetAllSquadsNearMarker(Team_GetPlayers(team)     , squadsNearSG_allied, pos, AIControl_MainControl_Settings.RetreatTactic_BattleRadius)
		
		--local maxHealth = Squad_GetHealthMax(squad)
		local healthLeft = Squad_GetHealth(squad)
		local healthLeftPercentage = Squad_GetHealthPercentage(squad)
		result = result + 9*max(0, 0.35 - healthLeftPercentage)
		
		if Squad_IsInHoldEntity(squad) then
			result = result - 1.5
			if Squad_IsUnderAttack(squad, 5) then
				if Squad_Count(squad) == 1 then result = result + 1.75 end
				result = result + 0.5
				if healthLeftPercentage < 0.275 or healthLeft < 70 then
					result = result + 5
				end
				result = result + max(0, min((90-healthLeft)/11, 5))
			end
			if Squad_IsAttacking(squad, 5) then
				result = result - 1.5
			end
		else
			if Squad_IsUnderAttack(squad, 5) then
				if Squad_Count(squad) == 1 then result = result + 1.75 end
				result = result + 0.25
				if healthLeftPercentage < 0.275 or healthLeft < 80 then
					result = result + 5
				end
				result = result + max(0, min((90-healthLeft)/11, 5))
			end
			if Squad_IsAttacking(squad, 5) then result = result - 0.35 end
		end
		
		if Squad_IsPinned(squad) then result = result + 0.75 end
		if Squad_HasTeamWeapon(squad) then result = result + 0.45 end
		
		local closestEnemyDistaceSq -- squared
		local enemyValue = 0
		local friendlyValue = 0
		local squadsNearSG_enemyCount = SGroup_Count(squadsNearSG_enemy)
		local squadsNearSG_alliedCount = SGroup_Count(squadsNearSG_allied)
		for i=1,squadsNearSG_enemyCount do
			local enemySquad = SGroup_GetSpawnedSquadAt(squadsNearSG_enemy, i)
			if AIControl_IsSquadVehicle(enemySquad) then
				enemyValue = enemyValue + Squad_GetHealth(enemySquad)/150
			else
				enemyValue = enemyValue + Squad_Count(enemySquad)*0.5
			end
			local dist = World_DistancePointToPoint(pos, Squad_GetPosition(enemySquad))
			if not closestEnemyDistaceSq or closestEnemyDistaceSq > closestEnemyDistaceSq then
				closestEnemyDistaceSq = dist
			end
		end
		for i=1,squadsNearSG_alliedCount do
			local friendlySquad = SGroup_GetSpawnedSquadAt(squadsNearSG_allied, i)
			if AIControl_IsSquadVehicle(friendlySquad) then
				friendlyValue = friendlyValue + Squad_GetHealth(friendlySquad)/150
			else
				friendlyValue = friendlyValue + Squad_Count(friendlySquad)*0.5
			end
		end
		
		if closestEnemyDistaceSq and closestEnemyDistaceSq < 25 then
			result = result + (25-closestEnemyDistaceSq)/35
		end
		
		SGroup_Destroy(squadsNearSG_enemy)
		SGroup_Destroy(squadsNearSG_allied)
		
		result = result + enemyValue*(1/8) - min(friendlyValue, enemyValue)/11
		
		return max(0, result)
	end,
	
	FUnitControl = function(squad, setting)
		local sg = SGroup_Create("aicontrol_uc_tempsg")
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local pos = Squad_GetPosition(squad)
		local interactablePoint = World_GetNearestInteractablePoint(pos)
		if World_DistancePointToPoint(pos, interactablePoint) < 5 then
			local x,y = AIControl_Grid.GetXY(pos)
			
			--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
			SGroup_Single(sg, squad)
			
			local syncWeapon = SyncWeapon_GetFromSGroup(sg)
			--local syncWeaponEntity = SyncWeapon_GetEntity(syncWeapon)
			if not Squad_IsInHoldEntity(squad) and not Squad_IsRetreating(squad) then
				--local isUnderAttack = Squad_IsUnderAttack(squad, 2)
				local healthPercentage = Squad_GetHealthPercentage(squad)
				local stepsTotal = setting['safety_radius_steps']
				local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({x, y}, 0, stepsTotal, team)
				sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
				
				local collectiveDanger = 0
				local totalArmor = 0
				for i,v in pairs(surroundingSafety) do
					collectiveDanger = collectiveDanger + v[3] + v[4]*0.01 - v[5]*0.1 - v[6]*0.0025
					totalArmor = totalArmor + v[7]
				end
				--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+9, pos.z, string.format('%.2f', collectiveDanger), 255, 255, 255)
				
				local lockSquad = false
				
				local playerHQPosition = Player_GetStartingPosition(player)
				local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
				local moveBackDanger = setting['move_back_danger']
				local retreatDanger = setting['retreat_danger']
				if setting['targets_armor'] then
					local dangerDecrease = min(setting['armor_danger_decrease_reduction_threshold'], totalArmor)*setting['armor_danger_decrease']
					
					moveBackDanger = moveBackDanger + dangerDecrease
					if retreatDanger >= 0 then
						retreatDanger = retreatDanger + dangerDecrease
					end
				end
				if collectiveDanger > moveBackDanger then
					
					-- We are in danger
					--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'in danger', 255, 255, 0)
					
					if g_AIControl_Components.UNIT_CONTROL_RETREAT then
						lockSquad = true
						
						if retreatDanger >= 0 and collectiveDanger > retreatDanger then
							local distanceToHq = World_DistancePointToPoint(pos, playerHQPosition)
							--Cmd_Move(sg, Player_GetStartingPosition(player))
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'retreating', 255, 0, 0)
							if distanceToHq > 20 then
								Cmd_Retreat(sg)
							end
						else
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'moving away', 255, 255, 0)
							
							local hqMult = 1.6
							local xBorderDistRatio = math.abs(pos.x) / wHalfWidth - 0.1
							if xBorderDistRatio > 0 then
								hqMult = hqMult + xBorderDistRatio*2
							end
							local yBorderDistRatio = math.abs(pos.z) / wHalfHeight - 0.1
							if yBorderDistRatio > 0 then
								hqMult = hqMult + yBorderDistRatio*2
							end
							local retreatDirection = AIControl_MainControl.GetRetreatDirection(surroundingSafety, pos, team, 1.5, 1.1, directionToHq, hqMult, 0.025, 0.5, 0)
							local retreatDistance = 5+min(30, max(0, 3*(collectiveDanger-2)))
							local retreatLocation = AIControl_MainControl.GetRetreatLocation(pos, retreatDirection, retreatDistance)
							
							local x2,y2 = AIControl_Grid.GetXY(retreatLocation)
							local retreatLocation2 = AIControl_MainControl.GetRetreatLocation(
								retreatLocation,
								AIControl_MainControl.GetRetreatDirection(
									AIControl_MainControl.GetSurroundingSafety({x2, y2}, 0, stepsTotal, team),
									retreatLocation,
									team, 1.5, 1.1, directionToHq, hqMult, 0.025, 0.5, 0),
								retreatDistance)
							
							if setting['move_reverse'] then
								local moveReverse = true
								local heading = Squad_GetHeading(squad)
								for i=0,Squad_Count(squad)-1 do
									local e = Squad_EntityAt(squad, i)
									if Entity_IsSyncWeapon(e) then
										heading = Entity_GetHeading(e)
									end
								end
								local angle = math.acos(
									(heading.x*retreatDirection.x+heading.z*retreatDirection.z) /
									(sqrt(heading.x*heading.x + heading.z*heading.z) * sqrt(retreatDirection.x*retreatDirection.x + retreatDirection.z*retreatDirection.z))
								)*180/3.14
								
								if angle < AIControl_MainControl_Settings_VehicleControl.ReverseThreshold then
									moveReverse = false
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'retreating', 255, 255, 255)
								else
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'retreating (reversed)', 255, 255, 255)
								end
								
								AIControl_MainControl.UnitControlTargets[team][squadGameID] = {true, retreatLocation}
								
								--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), 0, 125, 0, 'aicontrol_maincontrol')
								Command_SquadMovePos(player, sg, World_GetNearestInteractablePoint(retreatLocation), false, moveReverse)
								Command_SquadMovePos(player, sg, World_GetNearestInteractablePoint(retreatLocation2), true, moveReverse)
								Command_SquadMovePos(player, sg, playerHQPosition, true, moveReverse)
							else
								Cmd_Move(sg, World_GetNearestInteractablePoint(retreatLocation), false)
								Cmd_Move(sg, World_GetNearestInteractablePoint(retreatLocation2), true)
								Cmd_Move(sg, playerHQPosition, true)
							end
						end
					end
				else
					local targetSafetyData = AIControl_MainControl.GetSurroundingSafety({x, y}, setting['init_step'], setting['step_count'], team)
					sort(targetSafetyData, function(a, b) return a[3] > b[3] end)
					
					if targetSafetyData[1][3] > setting['setup_target_danger'] then
						
						--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+3, pos.z, 'setting up', 255, 255, 255)
						
						lockSquad = true
						
						local dangerMultiplier
						local safetyMultiplier
						local hqDirectionMultiplier
						local historyMultiplier
						local armorMultiplier
						if setting['targets_armor'] then
							dangerMultiplier = -3
							safetyMultiplier = -1
							hqDirectionMultiplier = -0.5
							historyMultiplier = -0.005
							armorMultiplier = 0
						else
							dangerMultiplier = -0.05
							safetyMultiplier = -0.0005
							hqDirectionMultiplier = 0
							historyMultiplier = 0
							armorMultiplier = -2
						end
						local headingDirection = AIControl_MainControl.GetRetreatDirection(targetSafetyData, pos, team, dangerMultiplier, safetyMultiplier, directionToHq, hqDirectionMultiplier, historyMultiplier, armorMultiplier, 0)
						local headingPos = AIControl_MainControl.GetRetreatLocation(pos, headingDirection, 25)
						--dr_drawline(World_Pos(pos.x, pos.y+0.35, pos.z), World_Pos(headingPos.x, headingPos.y+0.35, headingPos.z), 0, 125, 125, 'aicontrol_maincontrol')
						
						local setupWell = false
						--print(tostring(AIControl_MainControl.UnitControlTargets[team][squadGameID]))
						if AIControl_MainControl.UnitControlTargets[team][squadGameID] and not AIControl_MainControl.UnitControlTargets[team][squadGameID][1] then
							local heading = normalizeVector(World_Pos(
								AIControl_MainControl.UnitControlTargets[team][squadGameID][3].x - AIControl_MainControl.UnitControlTargets[team][squadGameID][2].x,
								0,
								AIControl_MainControl.UnitControlTargets[team][squadGameID][3].z - AIControl_MainControl.UnitControlTargets[team][squadGameID][2].z
							))
							local angle = math.acos(
								(heading.x*headingDirection.x+heading.z*headingDirection.z) /
								(sqrt(heading.x*heading.x + heading.z*heading.z) * sqrt(headingDirection.x*headingDirection.x + headingDirection.z*headingDirection.z))
							)*180/3.14
							
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'angle: '..string.format('%d', angle), 255, 255, 255)
							if setting['target_angle_threshold'] == -1 or angle < setting['target_angle_threshold'] then
								--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'setup well', 255, 0, 0)
								setupWell = true
							end
						end
						if setupWell and World_DistancePointToPoint(pos, AIControl_MainControl.UnitControlTargets[team][squadGameID][2]) > AIControl_MainControl_Settings_UnitControl.CoverSearchRadius*3 then
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+5, pos.z, 'NOT IN COVER', 255, 0, 0)
							setupWell = false
						end
						if not setupWell then
							local coverSearchPos = pos
							for i=0,Squad_Count(squad)-1 do
								local e = Squad_EntityAt(squad, i)
								if Entity_IsSyncWeapon(e) then
									coverSearchPos = Entity_GetPosition(e)
								end
							end
							
							if setting['attack_move_forward'] then
								Cmd_AttackMove(sg, headingPos, false)
							else
								local setupPos = pos
								if setting['search_cover'] then
									setupPos = Squad_FindCover(squad, pos, AIControl_MainControl_Settings_UnitControl.CoverSearchRadius)
									
									--dr_text3d('aicontrol_maincontrol', coverPos.x, coverPos.y+0.35, coverPos.z, 'o', 255, 255, 255)
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'new setup pos', 255, 0, 0)
								end
								
								AIControl_MainControl.UnitControlTargets[team][squadGameID] = {false, setupPos, headingPos}
								Command_SquadMovePosFacing(player, sg, setupPos, headingPos, false, false)
							end
						end
					end
				end
				
				if lockSquad then
					if not AIControl_MainControl_LockedSquads[team][squadGameID] then
						AIControl_MainControl_LockedSquads[team][squadGameID] = true
						if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
							AI_LockSquad(player, squad)
						end
					end
				else
					if AIControl_MainControl.UnitControlTargets[team][squadGameID] then
						AIControl_MainControl.UnitControlTargets[team][squadGameID] = nil
						AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = 0
					elseif AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] then
						AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] + 1
						if AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] > 7 then
							if AIControl_MainControl_LockedSquads[team][squadGameID] then
								if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
									AI_UnlockSquad(player, squad)
								end
							end
							AIControl_MainControl_LockedSquads[team][squadGameID] = nil
							AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = nil
						end
					else
						if AIControl_MainControl_LockedSquads[team][squadGameID] then
							if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
								AI_UnlockSquad(player, squad)
							end
							AIControl_MainControl_LockedSquads[team][squadGameID] = nil
						end
					end
				end
			end
		end
		SGroup_Destroy(sg)
	end,
	
	FVehicleControl = function(squad)
		local sg = SGroup_Create("aicontrol_vc_tempsg")
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local raceStr = Player_GetRaceName(player)
		local hasDisableCritical = false
		for i,v in pairs(AIControl_MainControl_Settings_VehicleControl.DisableCriticals) do
			if Squad_HasCritical(squad, v) then
				hasDisableCritical = true
				break
			end
		end
		local lockSquad = false
		if not hasDisableCritical then
			local lowHealth = false
			local healthPercentage = Squad_GetHealthPercentage(squad)
			local pos = Squad_GetPosition(squad)
			local interactablePoint = World_GetNearestInteractablePoint(pos)
			if World_DistancePointToPoint(pos, interactablePoint) < 5 then
				-- Retreat on low health
				local hasDamageCritical = false
				for i,v in pairs(AIControl_MainControl_Settings_VehicleControl.DamageCriticals) do
					if Squad_HasCritical(squad, v) then
						hasDamageCritical = true
						break
					end
				end
				
				if g_AIControl_Components.VEHICLE_CONTROL_RETREAT then
					if (AIControl_MainControl.VehicleControl.RepairsRetreat[team][squadGameID] and healthPercentage < 0.9)
							or (not Squad_IsAttacking(squad, 10) and (healthPercentage < 0.5 or hasDamageCritical)) then
						lockSquad = true
						lowHealth = true
						--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+3, pos.z, 'low health', 255, 0, 0)
					else
						AIControl_MainControl.VehicleControl.RepairsRetreat[team][squadGameID] = nil
					end
				end
				
				if not AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID]
						or (lowHealth and AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] > 20)
						or (not lowHealth and AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] > 6) then
					AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = nil
					--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
					
					SGroup_Single(sg, squad)
					
					local x,y = AIControl_Grid.GetXY(pos)
					
					local playerHQPosition = Player_GetStartingPosition(player)
					
					local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
					local initialStep = 0
					local stepsTotal = 10
					local maxDist = initialStep + stepsTotal
					local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({x, y}, initialStep, stepsTotal, team)
					sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
					
					local collectiveDanger = 0
					local friendlyArmor = 0
					for j,v in pairs(surroundingSafety) do
						collectiveDanger = collectiveDanger + v[3] + v[4]*0.01 - v[5]*0.1 - v[6]*0.005
						friendlyArmor = friendlyArmor + v[9]
					end
					
					local hqMult = 1.6
					local xBorderDistRatio = math.abs(pos.x) / wHalfWidth - 0.1
					if xBorderDistRatio > 0 then
						hqMult = hqMult + xBorderDistRatio*2
					end
					local yBorderDistRatio = math.abs(pos.z) / wHalfHeight - 0.1
					if yBorderDistRatio > 0 then
						hqMult = hqMult + yBorderDistRatio*2
					end
					local retreatDirection = AIControl_MainControl.GetRetreatDirection(surroundingSafety, pos, team, 1.5, 1.1, directionToHq, hqMult, 0.05, 0.5, 0)
					
					local baseDangerRequirement = AIControl_MainControl_Settings_VehicleControl.DefaultBaseDangerRequiredToRetreat
					local dangerRequirementDecreaseWithHealth = AIControl_MainControl_Settings_VehicleControl.DefaultDangerRequiredDecreaseWithHealth
					local dangerRequirementDecreaseWithFriendlyArmor = AIControl_MainControl_Settings_VehicleControl.DefaultDangerRequiredDecreaseWithFriendlyArmor
					local customSettings = AIControl_MainControl_Settings_VehicleControl.CustomVehicles[raceStr][removeModID(BP_GetName(Squad_GetBlueprint(squad)))]
					if customSettings then
						if customSettings[1] ~= nil then
							baseDangerRequirement = customSettings[1]
						end
						if customSettings[2] ~= nil then
							dangerRequirementDecreaseWithHealth = customSettings[2]
						end
						if customSettings[3] ~= nil then
							dangerRequirementDecreaseWithFriendlyArmor = customSettings[3]
						end
					end
					local dangerRequiredToRetreat = baseDangerRequirement - dangerRequirementDecreaseWithHealth*min(1, max(0, 1-(healthPercentage-0.25)/0.75)) + dangerRequirementDecreaseWithFriendlyArmor*friendlyArmor
					if not customSettings then
						local maxHealth = Squad_GetHealthMax(squad)
						if maxHealth < 650 then
							dangerRequiredToRetreat = dangerRequiredToRetreat - min(1, max(0, 1-(maxHealth-150)/(650-150))) * AIControl_MainControl_Settings_VehicleControl.DangerRequiredToRetreatDecreaseForLightVehicles
						end
					end
					local distToHq = World_DistancePointToPoint(pos, playerHQPosition)
					if distToHq < 75 then
						dangerRequiredToRetreat = dangerRequiredToRetreat + AIControl_MainControl_Settings_VehicleControl.DangerRequiredToRetreatIncreaseNearHQ*max(0, 1-(distToHq-25)*0.02)
					end
					
					local retreatDistance
					local additionalRetreatDistance
					if lowHealth then
						retreatDistance = 0
						additionalRetreatDistance = 30
					else
						retreatDistance = 25
						additionalRetreatDistance = max(0, min(25, 200*(collectiveDanger-max(0, dangerRequiredToRetreat))/max(1, dangerRequiredToRetreat)))
					end
					
					-- Retreat if in danger
					if g_AIControl_Components.VEHICLE_CONTROL_RETREAT then
						if not lockSquad then
							-- Retreat if in danger
							if collectiveDanger > dangerRequiredToRetreat then
								lockSquad = true
							end
						end
					end
					
					if lockSquad then
						
						local inSafety = false
						if lowHealth then
							local actualSafety = collectiveDanger < -0.5+0.4*healthPercentage
							if actualSafety or distToHq < 25 then
								--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'in safety', 255, 255, 0)
								if Squad_IsMoving(squad) then
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'stopped', 255, 255, 255)
									Cmd_Stop(sg)
								end
								if actualSafety then
									local vehicleCrew = Squad_GetVehicleMobileDriverSquad(squad)
									if vehicleCrew then
										local vehicleEntity = Squad_EntityAt(squad, 0)
										Entity_ApplyCritical(vehicleEntity, AIControl_MainControl_Settings_VehicleControl.DecrewCritical, 0)
										--local tmpEG = EGroup_Create('aicontrol_tmp') -- can't add squad entity to EG. Should add it one update later?
										--EGroup_Single(tmpEG, vehicleEntity)
										--Cmd_RecrewVehicle(sg, tmpEG, true)
										--EGroup_Destroy(tmpEG)
										--AI_LockSquad(vehicleCrew)
									end
								end
								inSafety = true
							end
						end
						if not inSafety then
							local retreatLocation = AIControl_MainControl.GetRetreatLocation(pos, retreatDirection, retreatDistance+additionalRetreatDistance)
							--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), 255, 125, 0, 'aicontrol_maincontrol')
							if additionalRetreatDistance > 7 and World_DistancePointToPoint(pos, retreatLocation) > 10 then
								local heading = Squad_GetHeading(squad)
								local retreatDirection = World_Pos(
									retreatLocation.x - pos.x,
									0,
									retreatLocation.z - pos.z
								)
								local angle = math.acos(
									(heading.x*retreatDirection.x+heading.z*retreatDirection.z) /
									(sqrt(heading.x*heading.x + heading.z*heading.z) * sqrt(retreatDirection.x*retreatDirection.x + retreatDirection.z*retreatDirection.z))
								)*180/3.14
								local moveReverse = true
								if angle < AIControl_MainControl_Settings_VehicleControl.ReverseThreshold then
									moveReverse = false
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'retreating', 255, 255, 255)
								else
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'retreating (reversed)', 255, 255, 255)
								end
								Command_SquadMovePos(player, sg, World_GetNearestInteractablePoint(retreatLocation), false, moveReverse)
								local x2,y2 = AIControl_Grid.GetXY(retreatLocation)
								local retreatLocation2 = AIControl_MainControl.GetRetreatLocation(
									retreatLocation,
									AIControl_MainControl.GetRetreatDirection(
										AIControl_MainControl.GetSurroundingSafety({x2, y2}, initialStep, stepsTotal, team),
										retreatLocation,
										team, 1.5, 1.1, directionToHq, hqMult*3, 0.05, 0.5),
									(retreatDistance+additionalRetreatDistance)*1.5)
								--dr_drawline(World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), World_Pos(retreatLocation2.x, retreatLocation2.y+1, retreatLocation2.z), 255, 0, 0, 'aicontrol_maincontrol')
								Command_SquadMovePos(player, sg, World_GetNearestInteractablePoint(retreatLocation2), true, moveReverse)
								--dr_drawline(World_Pos(retreatLocation2.x, retreatLocation2.y+1, retreatLocation2.z), World_Pos(playerHQPosition.x, playerHQPosition.y+1, playerHQPosition.z), 255, 0, 0, 'aicontrol_maincontrol')
								Command_SquadMovePos(player, sg, playerHQPosition, true, moveReverse)
								AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = 1
							else
								if Squad_IsMoving(squad) then
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'stopped', 255, 255, 255)
									Cmd_Stop(sg)
								end
							end
						end
					end
					
					if not lockSquad and pos.x > -wHalfWidth and pos.x < wHalfWidth and pos.z > -wHalfHeight and pos.z < wHalfHeight then
						local angleThreshold
						
						-- Rotate if facing badly
						local facingDirection
						if #surroundingSafety >= 2 and surroundingSafety[1][3] > 1.5 and surroundingSafety[2][3] > 1.5 then
							angleThreshold = 105
							if customSettings and customSettings[4] == true then
								facingDirection = Util_ScarPos(retreatDirection.x, retreatDirection.z)
							else
								facingDirection = Util_ScarPos(-retreatDirection.x, -retreatDirection.z)
							end
						else
							angleThreshold = 160
							if customSettings and customSettings[4] == true then
								facingDirection = Util_ScarPos(directionToHq.x, directionToHq.z)
							else
								facingDirection = Util_ScarPos(-directionToHq.x, -directionToHq.z)
							end
						end
						
						local heading = Squad_GetHeading(squad)
						
						local angle = math.acos(
							(facingDirection.x*heading.x+facingDirection.z*heading.z) /
							(sqrt(facingDirection.x*facingDirection.x + facingDirection.z*facingDirection.z) * sqrt(heading.x*heading.x + heading.z*heading.z))
						)*180/3.14
						
						if angle > angleThreshold then
							lockSquad = true
							
							if not AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] or AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] > 10 then
								AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = 0
								Command_SquadMovePosFacing(player, sg, pos, Util_ScarPos(pos.x + facingDirection.x*10, pos.z + facingDirection.z*10), false, false)
							else
								AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
							end
						else
							if AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] and AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] <= 10 then
								AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
							else
								AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = nil
							end
						end
						
					end
				elseif AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] then
					lockSquad = true
					AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] + 1
				end
			end
		end
		
		if lockSquad then
			if not AIControl_MainControl_LockedSquads[team][squadGameID] then
				AIControl_MainControl_LockedSquads[team][squadGameID] = true
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					AI_LockSquad(player, squad)
				end
			end
		elseif AIControl_MainControl_LockedSquads[team][squadGameID] then
			AIControl_MainControl_LockedSquads[team][squadGameID] = nil
			if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
				AI_UnlockSquad(player, squad)
			end
		end
		SGroup_Destroy(sg)
	end,
	
	GetBestClumpForRadius = function(team, x, y, radius, noFOW)
		if noFOW == nil then noFOW = false end
		local maxDanger = 0
		local maxDangerPos = nil
		local radiusSquared = radius*radius
		for i = max(1, floor(x-radius)),min(Dimensions[1], ceil(x+radius)) do
			local aSquared = (i-x)^2
			for j = max(1, floor(y-radius)),min(Dimensions[2], ceil(y+radius)) do
				local bSquared = (j-y)^2
				if aSquared + bSquared <= radiusSquared then
					if noFOW then
						if AIControl_Grid_DataClump[i][j][team] then
							if AIControl_Grid_DataClump[i][j][team] > maxDanger then
								maxDanger = AIControl_Grid_DataClump[i][j][team]
								maxDangerPos = {i, j}
							end
						end
					else
						if AIControl_Grid_DataClumpFOW[i][j][team] then
							if AIControl_Grid_DataClumpFOW[i][j][team] > maxDanger then
								maxDanger = AIControl_Grid_DataClumpFOW[i][j][team]
								maxDangerPos = {i, j}
							end
						end
					end
				end
			end
		end
		return maxDangerPos, maxDanger
	end,
	FBarrageControl = function(squad, setting)
		local sg = SGroup_Create("aicontrol_bc_tempsg")
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local lockSquad = false
		if not AIControl_MainControl_LockedSquads[team][squadGameID]
				or AIControl_MainControl_LockedSquads[team][squadGameID] == -1
				or ( -- also want to barrage with any 'setup' unit control squads
					AIControl_MainControl_LockedSquads[team][squadGameID] == 1 -- Unit control
					and AIControl_MainControl.UnitControlTargets[team][squadGameID] -- Has target
					and not AIControl_MainControl.UnitControlTargets[team][squadGameID][1] -- Target is not a move back target
					)
				then
			local curMunitions = Player_GetResource(player, RT_Munition)
			local desiredSaveUpAmount = min(AIControl_MainControl_Settings_BarrageControl.SaveUpAmount, AIControl_MainControl_Settings_BarrageControl.SaveUpAmountGrowthWithTime*World_GetGameTime())
			
			local shouldCast = curMunitions > desiredSaveUpAmount
			if not shouldCast then -- are we saving up?
				shouldCast = World_GetRand(0,100) < AIControl_MainControl_Settings_BarrageControl.ChanceToCastBelowsavedMunitionsThreshold
			end
			
			if shouldCast then
				local pos = Squad_GetPosition(squad)
				local x,y = AIControl_Grid.GetXY(pos)
				
				local totalAbilityWeight = 0
				for i=1,#setting do
					totalAbilityWeight = totalAbilityWeight + setting[i].weight
				end
				
				local weightRand = World_GetRand(0, totalAbilityWeight)
				local curWeight = 0
				for i=1,#setting do
					local v = setting[i]
					curWeight = curWeight + v.weight
					if curWeight >= weightRand then
						
						SGroup_Single(sg, squad)
						
						local castPosition = false
						
						if not v.positionFunc then
							local inProximityOfEnemy = false
							for i=1,World_GetPlayerCount() do
								local p2 = World_GetPlayerAt(i)
								if Player_GetRelationship(player, p2) == R_ENEMY and Prox_PlayerSquadsInProximityOfSquads(p2, sg, v.searchrange, false, nil) then
									inProximityOfEnemy = true
									break
								end
							end
							if inProximityOfEnemy then
								local clumpSearchRadius = v.searchrange/((Dimensions[3]+Dimensions[4])*0.5)
								--d r_drawCircle('aicontrol_maincontrol', pos.x, pos.y+10, pos.z, clumpSearchRadius*((Dimensions[1]+Dimensions[2])*0.5), 255, 255, 255)
								local bestClump, bestClumpThreat = AIControl_MainControl.GetBestClumpForRadius(enemyTeam, x, y, clumpSearchRadius, false)
								
								if bestClump and bestClumpThreat >= v.minThreatToCast then
									castPosition = AIControl_Grid_AveragePosData[bestClump[1]][bestClump[2]][enemyTeam]
									--dr_drawline(World_Pos(pos.x, pos.y+2, pos.z), World_Pos(castPosition.x, castPosition.y+2, castPosition.z), 255, 125, 125, 'aicontrol_maincontrol')
								end
							end
						else
							castPosition = v.positionFunc(squad, v)
						end
						
						if castPosition and Squad_CanCastAbilityOnPosition(squad, v.blueprint, castPosition) then
							Cmd_Ability(sg, v.blueprint, castPosition, World_Pos(0,0,0), false, false)
							AIControl_MainControl.BarrageControlLockTimers[squadGameID] = v.lockDuration/AIControl_Grid.SplitUpdateCount
							lockSquad = true
						end
						
						break
					end
				end
			end
		end
		if lockSquad then
			if not AIControl_MainControl_LockedSquads[team][squadGameID] then
				AIControl_MainControl_LockedSquads[team][squadGameID] = 3
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					AI_LockSquad(player, squad)
				end
			end
		else
			if AIControl_MainControl.BarrageControlLockTimers[squadGameID] then
				AIControl_MainControl.BarrageControlLockTimers[squadGameID] = AIControl_MainControl.BarrageControlLockTimers[squadGameID] - 1
				if AIControl_MainControl.BarrageControlLockTimers[squadGameID] <= 0 then
					if AIControl_MainControl_LockedSquads[team][squadGameID] then
						if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
							AI_UnlockSquad(player, squad)
						end
					end
					AIControl_MainControl.BarrageControlLockTimers[squadGameID] = nil
					AIControl_MainControl_LockedSquads[team][squadGameID] = nil
				end
			end
		end
		SGroup_Destroy(sg)
	end,
	
	GetSquadCoverPosition = function(squad, targetSquadPos)
		local pos = Squad_GetPosition(squad)
		
		--[[if targetSquadPos then
			local posDiff = World_Pos(targetSquadPos.x - pos.x, 0, targetSquadPos.z - pos.z)
			local posDiffLength = sqrt(posDiff.x*posDiff.x + posDiff.z*posDiff.z)
			if posDiffLength > 0 then
				local posDiffLengthM = 1/posDiffLength
				posDiff.x = posDiff.x*posDiffLengthM
				posDiff.z = posDiff.z*posDiffLengthM
				
				pos.x = pos.x + posDiff.x*7
				pos.z = pos.z + posDiff.z*7
			end
		end]]
		
		return Squad_FindCoverCompareCurrent(squad, pos, 25, 30, true)
	end,
	ExecuteCombatUnitAbility = function(sg, squad, ability)
		if ability.type == 'targeted' then
			local castPosition, castPosition2 = ability.position(squad)
			if castPosition and Squad_CanCastAbilityOnPosition(squad, ability.blueprint, castPosition) then
				local pos = Squad_GetPosition(squad)
				--dr_drawline(World_Pos(pos.x, pos.y+2, pos.z), World_Pos(castPosition.x, castPosition.y+2, castPosition.z), 0, 90, 0, 'aicontrol_maincontrol')
				local secondPosition = castPosition2 or World_Pos(0,0,0)
				Cmd_Ability(sg, ability.blueprint, castPosition, secondPosition, false, ability.queued)
				return true, castPosition, secondPosition
			end
		elseif ability.type == 'default' then
			if Squad_CanCastAbilityOnSquad(squad, ability.blueprint, squad) then
				Cmd_Ability(sg, ability.blueprint, nil, nil, false, ability.queued)
				return true, nil, nil
			end
		end
		return false, nil, nil
	end,
	FCombatUnitControl = function(squad, inCombat)
		local sg = SGroup_Create("aicontrol_cuc_tempsg")
		SGroup_Single(sg, squad)
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local pos = Squad_GetPosition(squad)
		if not AIControl_MainControl_LockedSquads[team][squadGameID]
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 6
				or AIControl_MainControl_LockedSquads[team][squadGameID] == -1 then
			
			local lockType = 4
			local lockSquad = false
			
			local targetSquadPos = false
			local targetSG = SGroup_Create('aicontrol_cuc_target_tempsg')
			Squad_GetAttackTargets(squad, targetSG)
			local targetSquad = nil
			if SGroup_CountSpawned(targetSG) > 0 then
				targetSquad = SGroup_GetSpawnedSquadAt(targetSG, 1)
			end
			SGroup_Destroy(targetSG)
			if targetSquad then
				targetSquadPos = Squad_GetPosition(targetSquad)
			end
			
			-- ask for support from surrounding squads
			if g_AIControl_Components.COMBATUNIT_CONTROL_HELP and inCombat and targetSquadPos then
				local sgNearby = SGroup_Create('aicontrol_cuc_tmpsurrounding')
				
				World_GetSquadsNearPoint(player, sgNearby, pos, AIControl_MainControl_Settings_CombatUnitControl.HelpRadius, OT_Ally)
				for i=1,SGroup_CountSpawned(sgNearby) do
					local nearbySquad = SGroup_GetSpawnedSquadAt(sgNearby, i)
					if
							not AIControl_IsSquadVehicle(nearbySquad)
							and not Squad_IsRetreating(nearbySquad)
							and not Squad_IsAttacking(nearbySquad, 20)
							and not Squad_IsSuppressed(nearbySquad)
							and not Squad_IsPinned(nearbySquad)
							and not Squad_IsInHoldSquad(nearbySquad)
							and not Squad_IsInHoldEntity(nearbySquad)
							and (
								not Squad_HasActiveCommand(nearbySquad)
								or (
									Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_Capture
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_CaptureTeamWeapon
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_DefuseMine
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_Construction
								)
							) then
						local nearbySquadPlayer = Squad_GetPlayerOwner(nearbySquad)
						local nearbySquadTeam = Player_GetTeam(nearbySquadPlayer)+1
						local nearbySquadID = Squad_GetGameID(nearbySquad)
						if
								not Player_IsHuman(nearbySquadPlayer)
								and (
									not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID]
									or (AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] and AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] <= 1)
								) then
							local raceStr = Player_GetRaceName(nearbySquadPlayer)
							local nearbySquadSBP = removeModID(BP_GetName(Squad_GetBlueprint(nearbySquad)))
							local ucSetting = AIControl_MainControl_Settings_UnitControl.UnitSettings[nearbySquadSBP]
							local bcSetting = AIControl_MainControl_Settings_BarrageControl.UnitSettings[nearbySquadSBP]
							if not ucSetting and not bcSetting
									and (
										not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID]
										or AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] == 4
										or AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] == 6
									) then
								
								local nearbySquadPos = Squad_GetPosition(nearbySquad)
								local hqPos = Player_GetStartingPosition(nearbySquadPlayer)
								local distToHQ = sqrt((nearbySquadPos.x - hqPos.x)^2 + (nearbySquadPos.z - hqPos.z)^2)
								if distToHQ > 30 then
									
									AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] = 10
									if not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] then
										AIControl_MainControl_LockedSquads[team][nearbySquadID] = 6
										if AI_IsAIPlayer(nearbySquadPlayer) and AI_IsEnabled(nearbySquadPlayer) then
											AI_LockSquad(nearbySquadPlayer, nearbySquad)
										end
									end
									
									local diffV = World_Pos(nearbySquadPos.x - targetSquadPos.x, 0, nearbySquadPos.z - targetSquadPos.z)
									diffVLengthM = 1/sqrt(diffV.x^2 + diffV.z^2)
									diffV.x = -diffV.z * diffVLengthM
									diffV.z =  diffV.x * diffVLengthM
									
									local xRand = abs(diffV.x*40)
									local yRand = abs(diffV.z*40)
									
									local attackPos = World_Pos(
										targetSquadPos.x - xRand + World_GetRand(0, ceil(xRand*20))/10,
										0,
										targetSquadPos.z - yRand + World_GetRand(0, ceil(yRand*20))/10
									)
									attackPos.y = World_GetHeightAt(attackPos.x, attackPos.z)
									
									local sg2 = SGroup_Create('aicontrol_cuc_tempsg2')
									SGroup_Single(sg2, nearbySquad)
									
									--dr_drawline(World_Pos(nearbySquadPos.x, nearbySquadPos.y+1, nearbySquadPos.z), World_Pos(attackPos.x, attackPos.y+1, attackPos.z), 255, 255, 0, 'aicontrol_maincontrol')
									
									Cmd_AttackMove(sg2, attackPos, false, nil, 12)
									SGroup_Destroy(sg2)
								end
								
							end
						end
					end
				end
				
				SGroup_Destroy(sgNearby)
			end
			
			if AIControl_MainControl_LockedSquads[team][squadGameID] == 5 then
				local timerData = AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID]
				if timerData then
					timerData.timer = timerData.timer - 1
					if timerData.timer <= 0 or (timerData.ability.verifyPosition and not timerData.ability.positionVerify(squad, timerData.position1, timerData.position2)) then
						AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID] = nil
					else
						lockSquad = true
					end
				end
			elseif AIControl_MainControl_LockedSquads[team][squadGameID] == 6 and not inCombat then
				if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] then
					AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] - 1
					if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] <= 0 then
						AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = nil
					else
						lockSquad = true
					end
				end
			elseif inCombat then
				
				local bpID = removeModID(BP_GetName(Squad_GetBlueprint(squad)))
				local setting = AIControl_MainControl_Settings_CombatUnitControl.UnitSettings[bpID]
				if setting then
					if setting.preset and setting.overrides then
						local finalSetting = {}
						for i,v in pairs(setting.preset) do
							if setting.overrides[i] then
								finalSetting[i] = setting.overrides[i]
							else
								finalSetting[i] = v
							end
						end
						setting = finalSetting
					end
				end
				
				local lockChance = 0
				if setting then
					lockChance = AIControl_MainControl_Settings_CombatUnitControl.BaseLockChance
					if setting.lock_chance ~= nil then
						lockChance = setting.lock_chance
					end
				elseif g_AIControl_Components.COMBATUNIT_CONTROL_ASSAULT or g_AIControl_Components.COMBATUNIT_CONTROL_TAKECOVER then
					lockChance = AIControl_MainControl_Settings_CombatUnitControl.BaseLockChance
				end
				lockSquad = World_GetRand(0, 100) < lockChance
				
				if lockSquad then
					local doingSomething = false
					
					if g_AIControl_Components.COMBATUNIT_CONTROL_ABILITIES and setting and setting.abilities then
						local ability_chance = setting.ability_chance or AIControl_MainControl_Settings_CombatUnitControl.DefaultAbilityChance
						if World_GetRand(0, 100) < ability_chance then
							local abilities = {}
							
							local totalAbilityWeight = 0
							for i=1,#setting.abilities do
								local ability = setting.abilities[i]
								if ability.preset and ability.overrides then
									local finalAbility = {}
									for j,v in pairs(ability.preset) do
										if ability.overrides[j] then
											finalAbility[j] = ability.overrides[j]
										else
											finalAbility[j] = v
										end
									end
									ability = finalAbility
								end
								abilities[i] = ability
								totalAbilityWeight = totalAbilityWeight + ability.weight
							end
							
							local weightRand = World_GetRand(0, totalAbilityWeight)
							local curWeight = 0
							for i=1,#abilities do
								local ability = abilities[i]
								curWeight = curWeight + ability.weight
								if curWeight >= weightRand then
									local shouldCast = true
									if ability.filter then
										shouldCast = ability.filter(squad)
									end
									if shouldCast then
										local position1, position2
										if ability.behavior then
											ability.behavior(squad, function()
												doingSomething, position1, position2 = AIControl_MainControl.ExecuteCombatUnitAbility(sg, squad, ability)
											end)
										else
											doingSomething, position1, position2 = AIControl_MainControl.ExecuteCombatUnitAbility(sg, squad, ability)
										end
										
										if doingSomething then
											lockType = 5
											AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID] = {
												timer = ability.lockDuration/AIControl_Grid.SplitUpdateCount,
												ability = ability,
												position1 = position1,
												position2 = position2
											}
										end
									end
									
									break
								end
							end
						end
					end
					
					if not doingSomething then
						if (g_AIControl_Components.COMBATUNIT_CONTROL_ASSAULT or g_AIControl_Components.COMBATUNIT_CONTROL_TAKECOVER) and
								(not Squad_HasActiveCommand(squad) or Squad_GetActiveCommand(squad) ~= SQUADSTATEID_Ability) then
							local closestSquadPos = targetSquadPos
							local closestSquadDist
							if targetSquadPos then
								closestSquadDist = World_DistancePointToPoint(pos, targetSquadPos)
							else
								closestSquadDist = 45
							end
							local sgNearby = SGroup_Create('aicontrol_cuc_tmpsurrounding')
							World_GetSquadsNearPoint(player, sgNearby, pos, closestSquadDist-10, OT_Enemy)
							for i=1,SGroup_CountSpawned(sgNearby) do
								local s = SGroup_GetSpawnedSquadAt(sgNearby, i)
								if not AIControl_IsSquadVehicle(s) then
									local sPos = Squad_GetPosition(s)
									local dist = World_DistancePointToPoint(pos, sPos)
									if dist < closestSquadDist then
										closestDist = dist
										closestSquadPos = sPos
									end
								end
							end
							SGroup_Destroy(sgNearby)
							
							local shouldAssault = false
							if g_AIControl_Components.COMBATUNIT_CONTROL_ASSAULT then
								shouldAssault = closestSquadPos and setting
								if shouldAssault and setting.assault_troops ~= nil then
									if type(setting.assault_troops) == 'function' then
										shouldAssault = setting.assault_troops(squad)
									else
										shouldAssault = setting.assault_troops
									end
								end
								if shouldAssault then
									local closeInDistance = setting.close_in_distance or AIControl_MainControl_Settings_CombatUnitControl.DefaultCloseInDistance
									local posDiff = World_Pos(pos.x - closestSquadPos.x, 0, pos.z - closestSquadPos.z)
									local posDiffLength = sqrt(posDiff.x*posDiff.x + posDiff.z*posDiff.z)
									shouldAssault = posDiffLength > closeInDistance
									if shouldAssault then
										local posDiffLengthM = 1/posDiffLength
										posDiff.x = posDiff.x*posDiffLengthM
										posDiff.z = posDiff.z*posDiffLengthM
										
										local targetPos = World_Pos(
											closestSquadPos.x + posDiff.x*closeInDistance,
											0,
											closestSquadPos.z + posDiff.z*closeInDistance)
										
										local coverPos = Squad_FindCover(squad, targetPos, 5)
										if World_DistanceSquaredPointToPoint(pos, coverPos) > 60 then
											Command_SquadMovePosFacing(player, sg, coverPos, closestSquadPos, false, false)
											--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(coverPos.x, coverPos.y+1, coverPos.z), 255, 0, 0, 'aicontrol_maincontrol')
										else
											Cmd_Stop(sg)
										end
									end
								end
							end
							if not shouldAssault then
								if g_AIControl_Components.COMBATUNIT_CONTROL_TAKECOVER then
									local coverPos = AIControl_MainControl.GetSquadCoverPosition(squad, closestSquadPos)
									if coverPos then
										if World_DistanceSquaredPointToPoint(pos, coverPos) > 16 then
											if closestSquadPos then
												Command_SquadMovePosFacing(player, sg, coverPos, closestSquadPos, false, false)
											else
												Command_SquadMovePos(player, sg, coverPos, false, false)
											end
											--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(coverPos.x, coverPos.y+1, coverPos.z), 0, 100, 0, 'aicontrol_maincontrol')
										--else
										--	Cmd_Stop(sg)
										end
									end
								else
									lockSquad = false
								end
							end
						else
							lockSquad = false
						end
					end
				end
			end
			
			if lockSquad then
				if not AIControl_MainControl_LockedSquads[team][squadGameID] then
					AIControl_MainControl_LockedSquads[team][squadGameID] = lockType
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_LockSquad(player, squad)
					end
				end
			else
				if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] then
					AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = nil
				end
				if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] then
					AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = nil
				end
				if AIControl_MainControl_LockedSquads[team][squadGameID] then
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_UnlockSquad(player, squad)
					end
				end
				AIControl_MainControl_LockedSquads[team][squadGameID] = nil
			end
		end
		SGroup_Destroy(sg)
	end,
}

--------------------------------------------------------------------------------------------------------------------

function AIControl_UpdateRule()
	AIControl_Grid.Update()
end
function AIControl__Init()
	AIControl_Grid = AIControl.Grid
	AIControl_Grid_Settings = AIControl_Grid.Settings
	Dimensions = AIControl_Grid.Dimensions
	
	AIControl_Grid_DataHistory = AIControl_Grid.DataHistory
	AIControl_Grid_t_DataHistory = AIControl_Grid.t_DataHistory
	
	AIControl_Grid_DataClump = AIControl_Grid.DataClump
	AIControl_Grid_DataClumpFOW = AIControl_Grid.DataClumpFOW
	
	--AIControl_Grid_DataSquads = AIControl_Grid.DataSquads
	--AIControl_Grid_t_DataSquads = AIControl_Grid.t_DataSquads
	AIControl_Grid_DataCounts = AIControl_Grid.DataCounts
	AIControl_Grid_t_DataCounts = AIControl_Grid.t_DataCounts
	AIControl_Grid_Data = AIControl_Grid.Data
	AIControl_Grid_t_Data = AIControl_Grid.t_Data
	AIControl_Grid_ArmorData = AIControl_Grid.ArmorData
	AIControl_Grid_t_ArmorData = AIControl_Grid.t_ArmorData
	AIControl_Grid_AveragePosData = AIControl_Grid.AveragePosData
	AIControl_Grid_t_AveragePosData = AIControl_Grid.t_AveragePosData
	
	AIControl_MainControl = AIControl.MainControl
	AIControl_MainControl_Settings = AIControl_MainControl.Settings
	AIControl_MainControl_Settings_UnitControl = AIControl_MainControl_Settings.UnitControl
	AIControl_MainControl_Settings_VehicleControl = AIControl_MainControl_Settings.VehicleControl
	AIControl_MainControl_Settings_BarrageControl = AIControl_MainControl_Settings.BarrageControl
	AIControl_MainControl_Settings_CombatUnitControl = AIControl_MainControl_Settings.CombatUnitControl
	AIControl_MainControl_LockedSquads = AIControl_MainControl.LockedSquads
	
	AIControl_Grid.ResetData(true)
	AIControl_MainControl.Init()
	AIControl_Grid.Update()
	Rule_AddInterval(AIControl_UpdateRule, 0.25)
end
function AIControl_Init()
	if g_AIControl_Enable then
		--dr_setdisplay("aicontrol_maincontrol", true)
		--dr_setautoclear("aicontrol_maincontrol", false)
		--dr_clear("aicontrol_maincontrol")
		--dr_setdisplay("aicontrol_grid", true)
		--dr_setautoclear("aicontrol_grid", false)
		--dr_clear("aicontrol_grid")
		
		AIControl_Grid.SetDimensions(AIControl_Grid_Settings.Init_Dimensions[1], AIControl_Grid_Settings.Init_Dimensions[2])
		AIControl_Grid.UpdateAIPlayers()
		
		Rule_AddOneShot(AIControl__Init, 0.125)
	end
end

AIControl_Grid = AIControl.Grid
AIControl_Grid_Settings = AIControl_Grid.Settings
Dimensions = AIControl_Grid.Dimensions

AIControl_Grid_DataHistory = AIControl_Grid.DataHistory
AIControl_Grid_t_DataHistory = AIControl_Grid.t_DataHistory

AIControl_Grid_DataClump = AIControl_Grid.DataClump
AIControl_Grid_DataClumpFOW = AIControl_Grid.DataClumpFOW

--AIControl_Grid_DataSquads = AIControl_Grid.DataSquads
--AIControl_Grid_t_DataSquads = AIControl_Grid.t_DataSquads
AIControl_Grid_DataCounts = AIControl_Grid.DataCounts
AIControl_Grid_t_DataCounts = AIControl_Grid.t_DataCounts
AIControl_Grid_Data = AIControl_Grid.Data
AIControl_Grid_t_Data = AIControl_Grid.t_Data
AIControl_Grid_ArmorData = AIControl_Grid.ArmorData
AIControl_Grid_t_ArmorData = AIControl_Grid.t_ArmorData
AIControl_Grid_AveragePosData = AIControl_Grid.AveragePosData
AIControl_Grid_t_AveragePosData = AIControl_Grid.t_AveragePosData

AIControl_MainControl = AIControl.MainControl
AIControl_MainControl_Settings = AIControl_MainControl.Settings
AIControl_MainControl_Settings_UnitControl = AIControl_MainControl_Settings.UnitControl
AIControl_MainControl_Settings_VehicleControl = AIControl_MainControl_Settings.VehicleControl
AIControl_MainControl_Settings_BarrageControl = AIControl_MainControl_Settings.BarrageControl
AIControl_MainControl_Settings_CombatUnitControl = AIControl_MainControl_Settings.CombatUnitControl
AIControl_MainControl_LockedSquads = AIControl_MainControl.LockedSquads

g_AIControl_MainControl_Settings = AIControl_MainControl.Settings
	
Scar_AddInit(AIControl_Init)

g_AIControl_Grid = AIControl.Grid
g_AIControl_MainControl = AIControl.MainControl

end
