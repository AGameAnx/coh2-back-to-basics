
--string.lpad = function(str, len, char)
--	if char == nil then char = ' ' end
--	return string.rep(char, len - string.len(str))..str
--end

local function normalizeVector(pos)
	local length = math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)
	return World_Pos(pos.x / length, pos.y / length, pos.z / length)
end

g_AIControl_Enable = true
g_AIControl_Pause = false

local AIControl = {}
local wHalfWidth = World_GetWidth()/2
local wHalfHeight = World_GetLength()/2

AIControl.UpdateInterval = 2.5 -- seconds
AIControl.Players = {}
AIControl.PlayerCount = 0

AIControl.Grid = {
	Settings = {
		SplitUpdates = true, -- If true, the update will be split to be performed over the course of UpdateInterval rather than once per UpdateInterval
		SplitUpdateCount = 4, -- Number of updates to be done during each UpdateInterval if SplitUpdates are enabled (make sure that dividing update interval by this doesn't produce long fractions)
		
		-- These settings will only be used on game start, changing them later on will not affect the actual values
		Init_Dimensions = {11, 11}, -- Initial dimensions table
		
		AutoDimensionsEnable = true, -- if this is enabled, world will automatically be divided into areas with dimensions closest to supplied dimensions table
		                             -- Otherwise, init dimensions will be used directly to divide map into that many parts
		HistoryLengthModifier = 100, -- Higher modifiers mean that units present in certain areas will be remembered longer
	},
	
	Dimensions = {0, 0, 1, 1}, -- {x divisions, y divisions, cell width, cell height}
	--DataHistoryStart = 0, -- the time in seconds in which we start our history data gathering
	DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell
	DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell
	Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell
	AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell
	
	MainControlUpdateStep = 0,
	SplitUpdateStep = 0,
	SplitUpdateSquads = {},
	
	SetDimensions = function(x, y, auto)
		local worldWidth, worldLength = World_GetWidth(), World_GetLength()
		if auto == nil then auto = AIControl.Grid.Settings.AutoDimensionsEnable end
		for i=1, AIControl.Grid.Dimensions[1] do
			if AIControl.Grid.DataSquads[i] then
				for j=1, AIControl.Grid.Dimensions[2] do
					if AIControl.Grid.DataSquads[i][j] then
						SGroup_Destroy(AIControl.Grid.DataSquads[i][j][1])
						SGroup_Destroy(AIControl.Grid.DataSquads[i][j][2])
					end
				end
			end
		end
		if auto then
			AIControl.Grid.Dimensions[1] = math.floor(worldWidth/x)
			AIControl.Grid.Dimensions[2] = math.floor(worldLength/y)
		else
			AIControl.Grid.Dimensions[1] = x
			AIControl.Grid.Dimensions[2] = y
		end
		AIControl.Grid.Dimensions[3] = worldWidth/AIControl.Grid.Dimensions[1]
		AIControl.Grid.Dimensions[4] = worldLength/AIControl.Grid.Dimensions[2]
		print("Dimensions: "..AIControl.Grid.Dimensions[1].."*"..AIControl.Grid.Dimensions[3].." x "..AIControl.Grid.Dimensions[2].."*"..AIControl.Grid.Dimensions[4])
		AIControl.Grid.DataHistory = {}
		AIControl.Grid.DataSquads = {}
		for i=1, AIControl.Grid.Dimensions[1] do
			AIControl.Grid.DataHistory[i] = {}
			AIControl.Grid.DataSquads[i] = {}
			for j=1, AIControl.Grid.Dimensions[2] do
				AIControl.Grid.DataHistory[i][j] = {0, 0}
				AIControl.Grid.DataSquads[i][j] = {SGroup_CreateIfNotFound("AIControl.Grid.DataSquads["..i.."]["..j.."][1]"), SGroup_CreateIfNotFound("AIControl.Grid.DataSquads["..i.."]["..j.."][2]")}
			end
		end
		--AIControl.Grid.DataHistoryStart = World_GetGameTime()/AIControl.UpdateInterval
	end,
	ResetData = function()
		for i=1,AIControl.Grid.Dimensions[1] do
			AIControl.Grid.Data[i] = {}
			AIControl.Grid.DataCounts[i] = {}
			AIControl.Grid.AveragePosData[i] = {}
			for j=1,AIControl.Grid.Dimensions[2] do
				AIControl.Grid.Data[i][j] = {0, 0}
				AIControl.Grid.DataCounts[i][j] = {0, 0}
				SGroup_Clear(AIControl.Grid.DataSquads[i][j][1])
				SGroup_Clear(AIControl.Grid.DataSquads[i][j][2])
				AIControl.Grid.AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
			end
		end
	end,
	
	UpdateAIPlayers = function() -- returns squad counts
		AIControl.PlayerCount = 0
		AIControl.Players = {}
		local squadCounts = {0, 0}
		for i=1,World_GetPlayerCount() do
			local player = World_GetPlayerAt(i)
			if not Player_IsHuman(player) then
				AIControl.PlayerCount = AIControl.PlayerCount + 1
				AIControl.Players[AIControl.PlayerCount] = i
			end
			local team = Player_GetTeam(player)+1
			if team == 1 or team == 2 then
				squadCounts[team] = squadCounts[team] + SGroup_CountSpawned(Player_GetSquads(player))
			end
		end
		return squadCounts
	end,
	Update = function()
		local squadCounts = AIControl.Grid.UpdateAIPlayers()
		if not AIControl.Grid.Settings.SplitUpdates or AIControl.Grid.SplitUpdateStep == 0 then
			AIControl.Grid.ResetData()
			for i=1,AIControl.Grid.Dimensions[1] do
				for j=1,AIControl.Grid.Dimensions[2] do
					AIControl.Grid.AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
					if squadCounts[1] > 0 then
						AIControl.Grid.DataHistory[i][j][1] = math.max(0, AIControl.Grid.DataHistory[i][j][1] - AIControl.Grid.DataHistory[i][j][1]/squadCounts[1]/(1+math.max(0, AIControl.Grid.Settings.HistoryLengthModifier)))
					end
					if squadCounts[2] > 0 then
						AIControl.Grid.DataHistory[i][j][2] = math.max(0, AIControl.Grid.DataHistory[i][j][2] - AIControl.Grid.DataHistory[i][j][2]/squadCounts[2]/(1+math.max(0, AIControl.Grid.Settings.HistoryLengthModifier)))
					end
				end
			end
			
			if AIControl.Grid.SplitUpdateStep == 0 then
				AIControl.Grid.SplitUpdateSquads = {}
				
				local allSquads = {}
				local sqCount = 0
				for i=1,World_GetPlayerCount() do
					local player = World_GetPlayerAt(i)
					local team = Player_GetTeam(player)+1
					if team == 1 or team == 2 then
						local pSquads = Player_GetSquads(player)
						for j=1,SGroup_CountSpawned(pSquads) do
							sqCount = sqCount + 1
							allSquads[sqCount] = SGroup_GetSpawnedSquadAt(pSquads, j)
						end
					end
				end
				
				if AIControl.Grid.SplitUpdateStep <= sqCount then
					local sqPerStep = math.ceil(sqCount/AIControl.Grid.Settings.SplitUpdateCount)
					for i=1,AIControl.Grid.Settings.SplitUpdateCount do
						AIControl.Grid.SplitUpdateSquads[i] = SGroup_CreateIfNotFound("sg_aicontrol_splitupdatesquads_"..i)
						for j=i*sqPerStep,math.min(sqCount, (i+1)*sqPerStep) do
							if allSquads[j] then
								SGroup_Add(AIControl.Grid.SplitUpdateSquads[i], allSquads[j])
							end
						end
					end
				end
			end
		end
		
		local squads
		if AIControl.Grid.Settings.SplitUpdates then
			AIControl.Grid.SplitUpdateStep = AIControl.Grid.SplitUpdateStep + 1
			squads = AIControl.Grid.SplitUpdateSquads[AIControl.Grid.SplitUpdateStep]
			if AIControl.Grid.SplitUpdateStep >= AIControl.Grid.Settings.SplitUpdateCount then
				AIControl.Grid.SplitUpdateStep = 0
			end
		else
			squads = SGroup_CreateIfNotFound("sg_temp_aicontrol_squads")
			for i=1,World_GetPlayerCount() do
				local player = World_GetPlayerAt(i)
				local team = Player_GetTeam(player)+1
				if team == 1 or team == 2 then
					local pSquads = Player_GetSquads(player)
					for j=1,SGroup_CountSpawned(pSquads) do
						local s = SGroup_GetSpawnedSquadAt(pSquads, j)
						SGroup_Add(squads, s)
					end
				end
			end
		end
		for i=1,SGroup_CountSpawned(squads) do
			local s = SGroup_GetSpawnedSquadAt(squads, i)
			local player = Squad_GetPlayerOwner(s)
			local team = Player_GetTeam(player)+1
			local enemyTeam
			if team == 1 then
				enemyTeam = 2
			else
				enemyTeam = 1
			end
			local position = Squad_GetPosition(s)
			local x = math.min(AIControl.Grid.Dimensions[1], math.max(1, math.floor((position.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1))
			local y = math.min(AIControl.Grid.Dimensions[2], math.max(1, math.floor((position.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1))
			
			local squadWeight = 1
			local squadHealthMax = Squad_GetHealthMax(s)
			
			--[[local canSee = true
			for j=1,World_GetPlayerCount() do
				local p = World_GetPlayerAt(j)
				local pTeam = Player_GetTeam(p)+1
				if pTeam == enemyTeam then
					canSee = Player_CanSeeSquad(p, s, false)
					break
				end
			end]]
			
			if Squad_GetMax(s) == 1 then
				if squadHealthMax > 200 then
					squadWeight = squadHealthMax/(50+(squadHealthMax-200)/10)
				else
					squadWeight = squadHealthMax/50
				end
			elseif Squad_Count(s) > 0 then
				squadWeight = Squad_Count(s)/2+squadHealthMax/150
			end
			
			AIControl.Grid.Data[x][y][team] = AIControl.Grid.Data[x][y][team] + squadWeight
			AIControl.Grid.DataCounts[x][y][team] = AIControl.Grid.DataCounts[x][y][team] + 1
			AIControl.Grid.DataHistory[x][y][team] = AIControl.Grid.DataHistory[x][y][team] + squadWeight/squadCounts[team]
			SGroup_Add(AIControl.Grid.DataSquads[x][y][team], s)
			
			AIControl.Grid.AveragePosData[x][y][team].x = AIControl.Grid.AveragePosData[x][y][team].x+position.x
			--AIControl.Grid.AveragePosData[x][y][team].y = AIControl.Grid.AveragePosData[x][y][team].y+position.y
			AIControl.Grid.AveragePosData[x][y][team].z = AIControl.Grid.AveragePosData[x][y][team].z+position.z
		end
		SGroup_Destroy(squads)
		
		if not AIControl.Grid.Settings.SplitUpdates or AIControl.Grid.SplitUpdateStep == 0 then
			for i=1,AIControl.Grid.Dimensions[1] do
				for j=1,AIControl.Grid.Dimensions[2] do
					if AIControl.Grid.DataCounts[i][j][1] > 1 then
						AIControl.Grid.AveragePosData[i][j][1].x = AIControl.Grid.AveragePosData[i][j][1].x/AIControl.Grid.DataCounts[i][j][1]
						--AIControl.Grid.AveragePosData[i][j][1].y = AIControl.Grid.AveragePosData[i][j][1].y/AIControl.Grid.DataCounts[i][j][1]
						AIControl.Grid.AveragePosData[i][j][1].z = AIControl.Grid.AveragePosData[i][j][1].z/AIControl.Grid.DataCounts[i][j][1]
					else
						AIControl.Grid.AveragePosData[i][j][1] = World_Pos(0, 0, 0)
					end
					if AIControl.Grid.DataCounts[i][j][2] > 1 then
						AIControl.Grid.AveragePosData[i][j][2].x = AIControl.Grid.AveragePosData[i][j][2].x/AIControl.Grid.DataCounts[i][j][2]
						--AIControl.Grid.AveragePosData[i][j][2].y = AIControl.Grid.AveragePosData[i][j][2].y/AIControl.Grid.DataCounts[i][j][2]
						AIControl.Grid.AveragePosData[i][j][2].z = AIControl.Grid.AveragePosData[i][j][2].z/AIControl.Grid.DataCounts[i][j][2]
					else
						AIControl.Grid.AveragePosData[i][j][2] = World_Pos(0, 0, 0)
					end
				end
			end
			dr_clear("aicontrolcustomdebug")
			--AIControl.Grid.DebugOutput(1)
			--AIControl.Grid.DebugOutput(2)
			
			AIControl.Grid.MainControlUpdateStep = AIControl.Grid.MainControlUpdateStep + 1
			if AIControl.Grid.MainControlUpdateStep >= AIControl.MainControl.Settings.Init_UpdateFreq then
				AIControl.Grid.MainControlUpdateStep = 0
				AIControl.MainControl.Update()
			end
			
			-- Get artillery position
			local highestPos = {{0, 0}, {0, 0}}
			local highestDanger = {0, 0}
			local highestPosFOW = {{0, 0}, {0, 0}}
			local highestDangerFOW = {0, 0}
			for team=1,2 do
				local enemyTeam
				if team == 1 then
					enemyTeam = 2
				else
					enemyTeam = 1
				end
				local player
				for i=1,World_GetPlayerCount() do
					local p = World_GetPlayerAt(i)
					if Player_GetTeam(p)+1 == team then
						player = p
						break
					end
				end
				for i=1,AIControl.Grid.Dimensions[1] do
					for j=1,AIControl.Grid.Dimensions[2] do
						if AIControl.Grid.Data[i][j][team]/AIControl.Grid.Data[i][j][enemyTeam] < 0.25 then
							if AIControl.Grid.Data[i][j][enemyTeam] > highestDangerFOW[team] then
								highestDangerFOW[team] = AIControl.Grid.Data[i][j][enemyTeam]
								highestPosFOW[team] = {i, j}
							end
							if AIControl.Grid.Data[i][j][enemyTeam] > highestDanger[team] and Player_CanSeePosition(player, AIControl.Grid.AveragePosData[i][j][enemyTeam]) then
								highestDanger[team] = AIControl.Grid.Data[i][j][enemyTeam]
								highestPos[team] = {i, j}
							end
						end
					end
				end
			end
		end
	end,
	DebugOutput = function(team)
		local function pr(i, j, team, val, offset)
			if offset == nil then offset = 0 end
			dr_text2d("aicontrolcustomdebug", 0.005+(team-1)*0.475+(AIControl.Grid.Dimensions[2]-j)/80, 0.005+offset+(AIControl.Grid.Dimensions[1]-i)/75, val, 255, 255, 255)
		end
		for i=1, AIControl.Grid.Dimensions[1] do
			for j=1, AIControl.Grid.Dimensions[2] do
				pr(i, j, team, string.format("%d", AIControl.Grid.Data[i][j][team]))
			end
		end
	end
}

--------------------------------------------------------------------------------------------------------------------

AIControl.MainControl = {
	Settings = {
		Init_UpdateFreq = 1, -- how many normal AI control updates we'll update this script
		SecondaryUpdateTicks = 9, -- every n updates we'll check for new HQs
		
		VehicleControl = {
			DisableCriticals = {
				BP_GetCriticalBlueprint('critical/vehicle_light_destroy_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_light_destroy_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_stuck_in_mud.lua'),
			},
			DamageCriticals = {
				BP_GetCriticalBlueprint('critical/vehicle_light_damage_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_light_damage_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_rear.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_rear_ramming.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_damage_engine_incremental.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_maingun.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_maingun_ramming.lua'),
				BP_GetCriticalBlueprint('critical/vehicle_destroy_quad_50.lua'),
			},
			ExcludeFromControl = {
				['soviet'] = {
					
				},
				['german'] = {
					
				},
				['aef'] = {
					
				},
				['west_german'] = {
					
				}
			}
		},
		
		AICheats = {
			ManpowerRate = 1.05,
			MunitionsRate = 1,
			FuelRate = 0.95,
			CommandPointRate = 1,
			
			StartingResources = 1.15,
			ExperienceReceived = 1.05,
			ProductionRate = 1.2,
			Upkeep = 0.95,
			SightRadius = 1,
		},
	},
	
	InitUpdateComplete = false,
	TerritorySectors = {},
	SecondaryUpdateTicks = 0,
	
	-- SGroups
	Vehicles = {},
	
	AICheatModifiers = {},
	LockedSquads = {{}, {}},
	
	VehicleControl = {
		RepairsRetreat = {{}, {}},
		FacingCmdTimers = {{}, {}},
	},
	
	Init = function()
		AIControl.MainControl.Vehicles = {SGroup_CreateIfNotFound("AIControl.MainControl.VT1"), SGroup_CreateIfNotFound("AIControl.MainControl.VT2")}
		
		AIControl.MainControl.SecondaryUpdate()
		AIControl.MainControl.Update()
	end,
	
	GetSafetyData = function(centerX, centerY, team) -- returns danger (float), history_danger (float)
		local enemyTeam
		if team == 1 then
			enemyTeam = 2
		else
			enemyTeam = 1
		end
		
		if centerX >= 1 and centerX <= AIControl.Grid.Dimensions[1]
			and centerY >= 1 and centerY <= AIControl.Grid.Dimensions[2] then
			return {
				AIControl.Grid.Data[centerX][centerY][enemyTeam],
				AIControl.Grid.DataHistory[centerX][centerY][enemyTeam],
				AIControl.Grid.Data[centerX][centerY][team],
				AIControl.Grid.DataHistory[centerX][centerY][team]
			}
		else
			return {0,0,0,0}
		end
	end,
	GetSurroundingSafetyData = function(gridPos, team, distance, maxDistance)
		local safetyData = AIControl.MainControl.GetSafetyData(gridPos[1], gridPos[2], team)
		local distanceMultiplier = math.min(1, 1.1 - distance/maxDistance)
		return {gridPos[1], gridPos[2], safetyData[1] * distanceMultiplier, safetyData[2] * distanceMultiplier, safetyData[3] * distanceMultiplier, safetyData[4] * distanceMultiplier}
	end,
	GetSurroundingSafety = function(pos, dist, steps, team)
		local result, resultCount = {}, 0
		
		--[[local gridPos = {
			math.floor((pos.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1,
			math.floor((pos.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1
		}]]
		
		local maxPointDistance
		if dist == 0 then
			resultCount = resultCount + 1
			result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData(pos, team, 0, 1)
			dist = 1
			maxPointDistance = math.sqrt((steps+1)^2+(steps+1)^2)
		else
			maxPointDistance = math.sqrt(steps^2+steps^2)
		end
		
		for x = dist,dist+steps do
			local curx
			curx = pos[1]+x
			if curx <= AIControl.Grid.Dimensions[1] then
				for y=dist,dist+steps do
					local pointDistance = math.sqrt((x-dist)^2 + (y-dist)^2)
					local cury
					cury = pos[2]+y
					if cury <= AIControl.Grid.Dimensions[2] then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
					cury = pos[2]-y
					if cury >= 1 then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
				end
			end
			curx = pos[1]-x
			if curx >= 1 then
				for y=dist,dist+steps do
					local pointDistance = math.sqrt((x-dist)^2 + (y-dist)^2)
					local cury
					cury = pos[2]+y
					if cury <= AIControl.Grid.Dimensions[2] then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
					cury = pos[2]-y
					if cury >= 1 then
						resultCount = resultCount + 1
						result[resultCount] = AIControl.MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
					end
				end
			end
		end
		return result
	end,
	
	Update = function()
		if g_AIControl_Pause then
			return
		end
		
		--print("Updating")
		
		AIControl.MainControl.SecondaryUpdateTicks = AIControl.MainControl.SecondaryUpdateTicks + 1
		if AIControl.MainControl.SecondaryUpdateTicks >= AIControl.MainControl.Settings.SecondaryUpdateTicks then
			AIControl.MainControl.SecondaryUpdate()
			AIControl.MainControl.SecondaryUpdateTicks = 0
		end
		
		-- Area safety
		local AreaSafetyData = {}
		
		for team=1,2 do
			local enemyTeam
			if team == 1 then enemyTeam = 2
			else enemyTeam = 1 end
			
			-- # Vehicle Control #
			local sg = SGroup_Create("aicontrol_v_tempsg")
			for i=1,SGroup_CountSpawned(AIControl.MainControl.Vehicles[team]) do
				local squad = SGroup_GetSpawnedSquadAt(AIControl.MainControl.Vehicles[team], i)
				local hasDisableCritical = false
				for i,v in pairs(AIControl.MainControl.Settings.VehicleControl.DisableCriticals) do
					if Squad_HasCritical(squad, v) then
						hasDisableCritical = true
						break
					end
				end
				if not hasDisableCritical then
					local squadGameID = Squad_GetGameID(squad)
					local player = Squad_GetPlayerOwner(squad)
					local healthPercentage = Squad_GetHealthPercentage(squad)
					--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
					
					SGroup_Single(sg, squad)
					
					local pos = Squad_GetPosition(squad)
					local x = math.floor((pos.x+wHalfWidth)/AIControl.Grid.Dimensions[3])+1
					local y = math.floor((pos.z+wHalfHeight)/AIControl.Grid.Dimensions[4])+1
					
					if x >= 1 and x <= AIControl.Grid.Dimensions[1]
						and y >= 1 and y <= AIControl.Grid.Dimensions[2] then
						
						local playerHQPosition = Player_GetStartingPosition(player)
						
						local lockSquad = false
						
						local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
						local initialStep = 0
						local stepsTotal = 9
						local maxDist = initialStep + stepsTotal
						local surroundingSafety = AIControl.MainControl.GetSurroundingSafety({x, y}, initialStep, stepsTotal, team)
						table.sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
						
						local collectiveDanger = 0
						for j,v in pairs(surroundingSafety) do
							local dist = math.sqrt((v[1]-x)^2 + (v[2]-y)^2)/maxDist
							local distMult = (1 - dist + dist*0.15)
							collectiveDanger = collectiveDanger + v[3] * 25 / math.min(27, math.max(1, dist*AIControl.Grid.Dimensions[1] / 2)) * distMult - v[5]*0.325 * distMult
						end
						
						collectiveDanger = collectiveDanger / (healthPercentage + (1-healthPercentage)*0.1)
						
						local highestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[1][1] ][ surroundingSafety[1][2] ][enemyTeam]
						local highestDangerDirection = normalizeVector(Util_ScarPos(
							highestDangerPosition.x - pos.x,
							highestDangerPosition.z - pos.z
						))
						
						local secondHighestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[2][1] ][ surroundingSafety[2][2] ][enemyTeam]
						local secondHighestDangerDirection = normalizeVector(Util_ScarPos(
							secondHighestDangerPosition.x - pos.x,
							secondHighestDangerPosition.z - pos.z
						))
						
						local retreatDirection = normalizeVector(Util_ScarPos(
							-highestDangerDirection.x*1.35-secondHighestDangerDirection.x*0.5+directionToHq.x*2,
							-highestDangerDirection.z*1.35-secondHighestDangerDirection.z*0.5+directionToHq.z*2
						))
						
						local lowHealth = false
						
						-- Retreat on low health
						local hasDamageCritical = false
						for i,v in pairs(AIControl.MainControl.Settings.VehicleControl.DamageCriticals) do
							if Squad_HasCritical(squad, v) then
								hasDamageCritical = true
								break
							end
						end
						if (AIControl.MainControl.VehicleControl.RepairsRetreat[team][squadGameID] and healthPercentage < 0.9)
								or hasDamageCritical
								or healthPercentage < 0.55 then
							lockSquad = true
							lowHealth = true
							--print('  RETREATING DUE TO LOW HEALTH!')
						else
							AIControl.MainControl.VehicleControl.RepairsRetreat[team][squadGameID] = nil
						end
						
						local dangerRequiredToRetreat = 62 - 8*math.min(1, 1-healthPercentage/0.55)
						
						local retreatDistance
						if lowHealth then
							retreatDistance = 110
						else
							retreatDistance = math.min(110, 3*(collectiveDanger-dangerRequiredToRetreat))
						end
						
						local retreatLocation = Util_ScarPos(
							pos.x + retreatDirection.x*retreatDistance,
							pos.z + retreatDirection.z*retreatDistance
						)
						
						-- Retreat if in danger
						if not lockSquad then
							-- Retreat if in danger
							--print('collective danger: '..collectiveDanger)
							--print('required danger to retreat: '..dangerRequiredToRetreat)
							if retreatDistance > 5 and collectiveDanger > dangerRequiredToRetreat then
								--print('  RETREATING DUE TO BEING IN DANGER!')
								lockSquad = true
							end
						end
						
						if lockSquad then
							
							local inSafety = false
							if lowHealth then
								local enemySafetyData = AIControl.MainControl.GetSafetyData(x, y, enemyTeam)
								if collectiveDanger < -2 then
									Cmd_Stop(sg)
									inSafety = true
								end
							elseif retreatDistance < 15 then
								inSafety = true
							end
							
							if not inSafety then
								if (not lowHealth or World_DistancePointToPoint(pos, retreatLocation) > 15) and World_DistancePointToPoint(pos, playerHQPosition) > 15 then
									Command_SquadMovePosFacing(player, sg, retreatLocation, Util_ScarPos(pos.x - retreatDirection.x*10, pos.z - retreatDirection.z*10), false, true)
								else
									Cmd_Stop(sg)
									lockSquad = false
								end
							else
								lockSquad = false
							end
						end
						
						if not lockSquad then
							local angleThreshold
							
							-- Rotate if facing badly
							if table.getn(surroundingSafety) > 0 and surroundingSafety[1][3] > 0.15 then
								angleThreshold = 30
								
								local highestDangerPosition = AIControl.Grid.AveragePosData[ surroundingSafety[1][1] ][ surroundingSafety[1][2] ][enemyTeam]
								local highestDangerDirection = normalizeVector(Util_ScarPos(
									highestDangerPosition.x - pos.x,
									highestDangerPosition.z - pos.z
								))
								
								retreatDirection = normalizeVector(Util_ScarPos(
									highestDangerDirection.x-directionToHq.x*0.5,
									highestDangerDirection.z-directionToHq.z*0.5
								))
							else
								angleThreshold = 170
								
								retreatDirection = Util_ScarPos(-directionToHq.x, -directionToHq.z)
							end
							
							local heading = Squad_GetHeading(squad)
							
							local angle = math.acos(
								(retreatDirection.x*heading.x+retreatDirection.z*heading.z) /
								(math.sqrt(retreatDirection.x*retreatDirection.x + retreatDirection.z*retreatDirection.z) * math.sqrt(heading.x*heading.x + heading.z*heading.z))
							)
							
							--print(string.format("  Angle diff: %.2f Threshold: %.2f", angle*180/3.14, angleThreshold))
							if angle > angleThreshold/180*3.14 then
								lockSquad = true
								
								if not AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] or AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] > 10 then
									--print("  ROTATING BADLY FACING TANK!")
									AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = 0
									Command_SquadMovePosFacing(player, sg, pos, Util_ScarPos(pos.x + retreatDirection.x*10, pos.z + retreatDirection.z*10), false, false)
								else
									AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
								end
							else
								if AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] and AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] <= 10 then
									AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
								else
									AIControl.MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = nil
								end
							end
							
						end
						
						if lockSquad then
							if not AIControl.MainControl.LockedSquads[team][squadGameID] then
								AIControl.MainControl.LockedSquads[team][squadGameID] = true
								if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
									AI_LockSquad(player, squad)
								end
							end
						elseif AIControl.MainControl.LockedSquads[team][squadGameID] then
							AIControl.MainControl.LockedSquads[team][squadGameID] = nil
							if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
								AI_UnlockSquad(player, squad)
							end
						end
					end
				end
			end
			SGroup_Destroy(sg)
		end
	end,

	SecondaryUpdate = function()
		for i=1, table.getn(AIControl.MainControl.AICheatModifiers) do
			Modifier_Remove(AIControl.MainControl.AICheatModifiers[i])
		end
		if AIControl.MainControl.InitUpdateComplete == false then
			if AIControl.MainControl.Settings.AICheats.StartingResources ~= 1 then
				for i=1,AIControl.PlayerCount do
					local player = World_GetPlayerAt(AIControl.Players[i])
					Player_SetResource(player, RT_Manpower, Player_GetResource(player, RT_Manpower)*AIControl.MainControl.Settings.AICheats.StartingResources)
				end
			end
			AIControl.MainControl.InitUpdateComplete = true
		end
		AIControl.MainControl.AICheatModifiers = {}
		for i=1,AIControl.PlayerCount do
			local player = World_GetPlayerAt(AIControl.Players[i])
			
			if AIControl.MainControl.Settings.AICheats.ManpowerRate ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerResourceRate(player, RT_Manpower, AIControl.MainControl.Settings.AICheats.ManpowerRate)
			end
			if AIControl.MainControl.Settings.AICheats.MunitionsRate ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerResourceRate(player, RT_Munition, AIControl.MainControl.Settings.AICheats.MunitionsRate)
			end
			if AIControl.MainControl.Settings.AICheats.FuelRate ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerResourceRate(player, RT_Fuel, AIControl.MainControl.Settings.AICheats.FuelRate)
			end
			if AIControl.MainControl.Settings.AICheats.CommandPointRate ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerResourceRate(player, RT_Command, AIControl.MainControl.Settings.AICheats.CommandPointRate)
			end
			
			if AIControl.MainControl.Settings.AICheats.ExperienceReceived ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerExperienceReceived(player, AIControl.MainControl.Settings.AICheats.ExperienceReceived)
			end
			if AIControl.MainControl.Settings.AICheats.ProductionRate ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerProductionRate(player, AIControl.MainControl.Settings.AICheats.ProductionRate)
			end
			if AIControl.MainControl.Settings.AICheats.Upkeep ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_Upkeep(player, AIControl.MainControl.Settings.AICheats.Upkeep)
			end
			if AIControl.MainControl.Settings.AICheats.SightRadius ~= 1 then
				AIControl.MainControl.AICheatModifiers[table.getn(AIControl.MainControl.AICheatModifiers)+1] = Modify_PlayerSightRadius(player, AIControl.MainControl.Settings.AICheats.SightRadius)
			end
		end
		
		-- Find all controlled squads
		local targets = {{}, {}}
		SGroup_Clear(AIControl.MainControl.Vehicles[1])
		SGroup_Clear(AIControl.MainControl.Vehicles[2])
		for i=1,AIControl.PlayerCount do
			local player = World_GetPlayerAt(AIControl.Players[i])
			local team = Player_GetTeam(player)+1
			local squads = Player_GetSquads(player)
			for j=1,SGroup_CountSpawned(squads) do
				local s = SGroup_GetSpawnedSquadAt(squads, j)
				
				local sbp = Squad_GetBlueprint(s)
				local raceStr = Player_GetRaceName(player)
				local bpid = BP_GetName(sbp)
				local exclude = AIControl.MainControl.Settings.VehicleControl.ExcludeFromControl[raceStr] and AIControl.MainControl.Settings.VehicleControl.ExcludeFromControl[raceStr][bpid]
				if not exclude and Squad_GetMax(s) == 1 and Squad_GetHealthMax(s) > 150 then -- vehicle control
					SGroup_Add(AIControl.MainControl.Vehicles[team], s)
				end
			end
		end
	end,
}

--------------------------------------------------------------------------------------------------------------------

function AIControl_Grid_Update()
	AIControl.Grid.Update()
end
function AIControl__Init()
	AIControl.Grid.Update()
	AIControl.MainControl.Init()
	
	if AIControl.Grid.Settings.SplitUpdates then
		Rule_AddInterval(AIControl_Grid_Update, AIControl.UpdateInterval/AIControl.Grid.Settings.SplitUpdateCount)
	else
		Rule_AddInterval(AIControl_Grid_Update, AIControl.UpdateInterval)
	end
end
function AIControl_Init()
	if g_AIControl_Enable then
		dr_setdisplay("aicontrolcustomdebug", true)
		dr_setautoclear("aicontrolcustomdebug", false)
		dr_clear("aicontrolcustomdebug")
		
		AIControl.Grid.SetDimensions(AIControl.Grid.Settings.Init_Dimensions[1], AIControl.Grid.Settings.Init_Dimensions[2])
		AIControl.Grid.UpdateAIPlayers()
		
		Rule_AddOneShot(AIControl__Init, 1)
	end
end

Scar_AddInit(AIControl_Init)
